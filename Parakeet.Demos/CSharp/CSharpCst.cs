// DO NOT EDIT: Autogenerated file created on 2023-03-22 2:06:58 PM. 
using System;
using System.Linq;

namespace Parakeet.Demos.CSharp
{
    // Original Rule: (Digits+(FractionalPart)?+(ExponentPart)?+(FloatSuffix)?)
    // Only Nodes: 
    public class FloatLiteral : CstNode
    {
        public FloatLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FloatLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("0x"|"0X")+HexDigit+(HexDigit)*+(IntegerSuffix)?)
    // Only Nodes: 
    public class HexLiteral : CstNode
    {
        public HexLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new HexLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("0b"|("0B"+BinDigit+(BinDigit)*+(IntegerSuffix)?))
    // Only Nodes: 
    public class BinaryLiteral : CstNode
    {
        public BinaryLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BinaryLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (Digits+!([\x2EDFMdfm])+(IntegerSuffix)?)
    // Only Nodes: 
    public class IntegerLiteral : CstNode
    {
        public IntegerLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new IntegerLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (('@')?+'"'+(StringLiteralChar)*+'"')
    // Only Nodes: 
    public class StringLiteral : CstNode
    {
        public StringLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new StringLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('''+CharLiteralChar+''')
    // Only Nodes: 
    public class CharLiteral : CstNode
    {
        public CharLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CharLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("true"+!(IdentifierChar)+WS)|("false"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class BooleanLiteral : CstNode
    {
        public BooleanLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BooleanLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("null"+!(IdentifierChar)+WS)
    // Only Nodes: 
    public class NullLiteral : CstNode
    {
        public NullLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new NullLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("value"+!(IdentifierChar)+WS)
    // Only Nodes: 
    public class ValueLiteral : CstNode
    {
        public ValueLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ValueLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((HexLiteral+WS)|(BinaryLiteral+WS)|(FloatLiteral+WS)|(IntegerLiteral+WS)|(StringLiteral+WS)|(CharLiteral+WS)|(BooleanLiteral+WS)|(NullLiteral+WS)|(ValueLiteral+WS))
    // Only Nodes: ((HexLiteral)|(BinaryLiteral)|(FloatLiteral)|(IntegerLiteral)|(StringLiteral)|(CharLiteral)|(BooleanLiteral)|(NullLiteral)|(ValueLiteral))
    public class Literal : CstChoice
    {
        public Literal(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Literal(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
        public CstSequence SequenceRule_2 => Children[0] as CstSequence;
        public CstSequence SequenceRule_3 => Children[0] as CstSequence;
        public CstSequence SequenceRule_4 => Children[0] as CstSequence;
        public CstSequence SequenceRule_5 => Children[0] as CstSequence;
        public CstSequence SequenceRule_6 => Children[0] as CstSequence;
        public CstSequence SequenceRule_7 => Children[0] as CstSequence;
        public CstSequence SequenceRule_8 => Children[0] as CstSequence;
    }

    // Original Rule: ((">>>="+WS)|(">>>"+WS)|(">>="+WS)|("<<="+WS)|("\x26\x26="+WS)|("||="+WS)|(">>"+WS)|("<<"+WS)|("\x26\x26"+WS)|("||"+WS)|("+="+WS)|("\x2D="+WS)|("\x2A="+WS)|("\x2F="+WS)|("\x25="+WS)|("\x26="+WS)|("|="+WS)|("^="+WS)|("<="+WS)|(">="+WS)|("=="+WS)|("\x21="+WS)|("\x3F\x3F"+WS)|("\x3F="+WS)|('+'+WS)|('-'+WS)|('*'+WS)|('/'+WS)|('%'+WS)|('&'+WS)|('|'+WS)|('^'+WS)|('='+WS)|('<'+WS)|('>'+WS))
    // Only Nodes: 
    public class BinaryOperator : CstNode
    {
        public BinaryOperator(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BinaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('('+WS+TypeExpr+WS+')'+WS+Expression+WS)
    // Only Nodes: (TypeExpr+Expression)
    public class CastExpression : CstSequence
    {
        public CastExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CastExpression(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: (("++"+WS)|("\x2D\x2D"+WS)|('!'+WS)|('-'+WS)|('+'+WS)|('~'+WS))
    // Only Nodes: 
    public class UnaryOperator : CstNode
    {
        public UnaryOperator(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new UnaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('['+WS+Expression+WS+']'+WS)
    // Only Nodes: (Expression)
    public class Indexer : CstSequence
    {
        public Indexer(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Indexer(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((">>>"+WS)|("++"+WS)|("\x2D\x2D"+WS)|("<<"+WS)|(">>"+WS)|("=="+WS)|("\x21="+WS)|("<="+WS)|(">="+WS)|('+'+WS)|('-'+WS)|('!'+WS)|('~'+WS)|('*'+WS)|('/'+WS)|('%'+WS)|('&'+WS)|('|'+WS)|('^'+WS)|('<'+WS)|('>'+WS))
    // Only Nodes: 
    public class OverloadableOperator : CstNode
    {
        public OverloadableOperator(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new OverloadableOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("++"+WS)|("\x2D\x2D"+WS)|('!'+WS)|(MemberAccess+WS)|(ConditionalMemberAccess+WS)|(FunctionArgs+WS)|(Indexer+WS)|(TernaryOperation+WS)|(BinaryOperation+WS)|(IsOperation+WS)|(AsOperation+WS))
    // Only Nodes: ((MemberAccess)|(ConditionalMemberAccess)|(FunctionArgs)|(Indexer)|(TernaryOperation)|(BinaryOperation)|(IsOperation)|(AsOperation))
    public class PostfixOperator : CstChoice
    {
        public PostfixOperator(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new PostfixOperator(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
        public CstSequence SequenceRule_2 => Children[0] as CstSequence;
        public CstSequence SequenceRule_3 => Children[0] as CstSequence;
        public CstSequence SequenceRule_4 => Children[0] as CstSequence;
        public CstSequence SequenceRule_5 => Children[0] as CstSequence;
        public CstSequence SequenceRule_6 => Children[0] as CstSequence;
        public CstSequence SequenceRule_7 => Children[0] as CstSequence;
    }

    // Original Rule: (IdentifierFirstChar+(IdentifierChar)*)
    // Only Nodes: 
    public class Identifier : CstNode
    {
        public Identifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Identifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (!("=>")+BinaryOperator+WS+_RECOVER_+Expression+WS)
    // Only Nodes: (BinaryOperator+Expression)
    public class BinaryOperation : CstSequence
    {
        public BinaryOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BinaryOperation(Children.Select(f).ToArray());
        public BinaryOperator BinaryOperator => Children[0] as BinaryOperator;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: ('?'+WS+_RECOVER_+Expression+WS+':'+WS+Expression+WS)
    // Only Nodes: (Expression+Expression)
    public class TernaryOperation : CstSequence
    {
        public TernaryOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TernaryOperation(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
        public Expression Expression_1 => Children[1] as Expression;
    }

    // Original Rule: ('('+WS+(((Expression+WS+WS+((Comma+Expression+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((Expression+((Expression))*))?)
    public class ParenthesizedExpression : CstSequence
    {
        public ParenthesizedExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ParenthesizedExpression(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ("throw"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS)
    // Only Nodes: (Expression)
    public class ThrowExpression : CstSequence
    {
        public ThrowExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ThrowExpression(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((TypeExpr+WS+Identifier+WS)|(Identifier+WS))
    // Only Nodes: ((TypeExpr+Identifier)|(Identifier))
    public class LambdaParameter : CstChoice
    {
        public LambdaParameter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new LambdaParameter(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: ((LambdaParameter+WS)|('('+WS+(((LambdaParameter+WS+WS+((Comma+LambdaParameter+WS+WS))*)+(Comma)?))?+')'+WS))
    // Only Nodes: ((LambdaParameter)|(((LambdaParameter+((LambdaParameter))*))?))
    public class LambdaParameters : CstChoice
    {
        public LambdaParameters(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new LambdaParameters(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: ((CompoundStatement+WS)|(Expression+WS))
    // Only Nodes: ((CompoundStatement)|(Expression))
    public class LambdaBody : CstChoice
    {
        public LambdaBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new LambdaBody(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: (LambdaParameters+WS+"=>"+WS+_RECOVER_+LambdaBody+WS)
    // Only Nodes: (LambdaParameters+LambdaBody)
    public class LambdaExpr : CstSequence
    {
        public LambdaExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new LambdaExpr(Children.Select(f).ToArray());
        public LambdaParameters LambdaParameters => Children[0] as LambdaParameters;
        public LambdaBody LambdaBody => Children[1] as LambdaBody;
    }

    // Original Rule: ('.'+WS+Identifier+WS)
    // Only Nodes: (Identifier)
    public class MemberAccess : CstSequence
    {
        public MemberAccess(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new MemberAccess(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
    }

    // Original Rule: ("\x3F\x2E"+WS+Identifier+WS)
    // Only Nodes: (Identifier)
    public class ConditionalMemberAccess : CstSequence
    {
        public ConditionalMemberAccess(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ConditionalMemberAccess(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
    }

    // Original Rule: ("typeof"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+TypeExpr+WS+')'+WS)
    // Only Nodes: (TypeExpr)
    public class TypeOf : CstSequence
    {
        public TypeOf(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeOf(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
    }

    // Original Rule: ("nameof"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+Expression+WS+')'+WS)
    // Only Nodes: (Expression)
    public class NameOf : CstSequence
    {
        public NameOf(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new NameOf(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("default"+!(IdentifierChar)+WS+_RECOVER_+(('('+WS+TypeExpr+WS+')'+WS))?)
    // Only Nodes: (((TypeExpr))?)
    public class Default : CstSequence
    {
        public Default(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Default(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((Identifier+WS+'='+WS+_RECOVER_+Expression+WS)|(Expression+WS))
    // Only Nodes: ((Identifier+Expression)|(Expression))
    public class InitializerClause : CstChoice
    {
        public InitializerClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new InitializerClause(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: ('{'+WS+_RECOVER_+(((InitializerClause+WS+WS+((Comma+InitializerClause+WS+WS))*)+(Comma)?))?+'}'+WS)
    // Only Nodes: (((InitializerClause+((InitializerClause))*))?)
    public class Initializer : CstSequence
    {
        public Initializer(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Initializer(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ('['+WS+Expression+WS+']'+WS)
    // Only Nodes: (Expression)
    public class ArraySizeSpecifier : CstSequence
    {
        public ArraySizeSpecifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ArraySizeSpecifier(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("new"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((FunctionArgs+WS))?+((ArraySizeSpecifier+WS))?+((Initializer+WS))?)
    // Only Nodes: (TypeExpr+((FunctionArgs))?+((ArraySizeSpecifier))?+((Initializer))?)
    public class NewOperation : CstSequence
    {
        public NewOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new NewOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public CstOptional<CstNode> SequenceRule => Children[1] as CstOptional<CstNode>;
        public CstOptional<CstNode> SequenceRule_1 => Children[2] as CstOptional<CstNode>;
        public CstOptional<CstNode> SequenceRule_2 => Children[3] as CstOptional<CstNode>;
    }

    // Original Rule: ("is"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((Identifier+WS))?)
    // Only Nodes: (TypeExpr+((Identifier))?)
    public class IsOperation : CstSequence
    {
        public IsOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new IsOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public CstOptional<CstNode> SequenceRule => Children[1] as CstOptional<CstNode>;
    }

    // Original Rule: ("as"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((Identifier+WS))?)
    // Only Nodes: (TypeExpr+((Identifier))?)
    public class AsOperation : CstSequence
    {
        public AsOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new AsOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public CstOptional<CstNode> SequenceRule => Children[1] as CstOptional<CstNode>;
    }

    // Original Rule: (('{'+WS+_RECOVER_+Expression+WS+'}'+WS)|StringLiteralChar)
    // Only Nodes: ((Expression))
    public class StringInterpolationContent : CstChoice
    {
        public StringInterpolationContent(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new StringInterpolationContent(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
    }

    // Original Rule: ('$'+_RECOVER_+'"'+((StringInterpolationContent+WS))*+'"')
    // Only Nodes: (((StringInterpolationContent))*)
    public class StringInterpolation : CstSequence
    {
        public StringInterpolation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new StringInterpolation(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (("params"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS)|("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class FunctionArgKeyword : CstNode
    {
        public FunctionArgKeyword(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FunctionArgKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (((FunctionArgKeyword+WS))*+Expression+WS)
    // Only Nodes: (((FunctionArgKeyword))*+Expression)
    public class FunctionArg : CstSequence
    {
        public FunctionArg(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FunctionArg(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: ('('+WS+(((FunctionArg+WS+WS+((Comma+FunctionArg+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((FunctionArg+((FunctionArg))*))?)
    public class FunctionArgs : CstSequence
    {
        public FunctionArgs(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FunctionArgs(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((LambdaExpr+WS)|(CastExpression+WS)|(ParenthesizedExpression+WS)|(ThrowExpression+WS)|(Literal+WS)|(TypeOf+WS)|(NameOf+WS)|(Default+WS)|(NewOperation+WS)|(StringInterpolation+WS)|(Identifier+WS))
    // Only Nodes: ((LambdaExpr)|(CastExpression)|(ParenthesizedExpression)|(ThrowExpression)|(Literal)|(TypeOf)|(NameOf)|(Default)|(NewOperation)|(StringInterpolation)|(Identifier))
    public class LeafExpression : CstChoice
    {
        public LeafExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new LeafExpression(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
        public CstSequence SequenceRule_2 => Children[0] as CstSequence;
        public CstSequence SequenceRule_3 => Children[0] as CstSequence;
        public CstSequence SequenceRule_4 => Children[0] as CstSequence;
        public CstSequence SequenceRule_5 => Children[0] as CstSequence;
        public CstSequence SequenceRule_6 => Children[0] as CstSequence;
        public CstSequence SequenceRule_7 => Children[0] as CstSequence;
        public CstSequence SequenceRule_8 => Children[0] as CstSequence;
        public CstSequence SequenceRule_9 => Children[0] as CstSequence;
        public CstSequence SequenceRule_10 => Children[0] as CstSequence;
    }

    // Original Rule: (((UnaryOperator+WS))*+LeafExpression+WS+((PostfixOperator+WS))*)
    // Only Nodes: (((UnaryOperator))*+LeafExpression+((PostfixOperator))*)
    public class Expression : CstSequence
    {
        public Expression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Expression(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
        public LeafExpression LeafExpression => Children[1] as LeafExpression;
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule_1 => Children[2] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (Expression+WS+_RECOVER_+EOS)
    // Only Nodes: (Expression)
    public class ExpressionStatement : CstSequence
    {
        public ExpressionStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ExpressionStatement(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("else"+!(IdentifierChar)+WS+_RECOVER_+Statement+WS)
    // Only Nodes: (Statement)
    public class ElseClause : CstSequence
    {
        public ElseClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ElseClause(Children.Select(f).ToArray());
        public Statement Statement => Children[0] as Statement;
    }

    // Original Rule: ("if"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS+Statement+WS+((ElseClause+WS))?)
    // Only Nodes: (ParenthesizedExpression+Statement+((ElseClause))?)
    public class IfStatement : CstSequence
    {
        public IfStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new IfStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
        public Statement Statement => Children[1] as Statement;
        public CstOptional<CstNode> SequenceRule => Children[2] as CstOptional<CstNode>;
    }

    // Original Rule: ("while"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS+Statement+WS)
    // Only Nodes: (ParenthesizedExpression+Statement)
    public class WhileStatement : CstSequence
    {
        public WhileStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new WhileStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
        public Statement Statement => Children[1] as Statement;
    }

    // Original Rule: ("do"+!(IdentifierChar)+WS+_RECOVER_+Statement+WS+"while"+!(IdentifierChar)+WS+ParenthesizedExpression+WS+EOS)
    // Only Nodes: (Statement+ParenthesizedExpression)
    public class DoWhileStatement : CstSequence
    {
        public DoWhileStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new DoWhileStatement(Children.Select(f).ToArray());
        public Statement Statement => Children[0] as Statement;
        public ParenthesizedExpression ParenthesizedExpression => Children[1] as ParenthesizedExpression;
    }

    // Original Rule: ("return"+!(IdentifierChar)+WS+_RECOVER_+((Expression+WS))?+EOS)
    // Only Nodes: (((Expression))?)
    public class ReturnStatement : CstSequence
    {
        public ReturnStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ReturnStatement(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ("break"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    public class BreakStatement : CstNode
    {
        public BreakStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BreakStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("yield"+!(IdentifierChar)+WS+_RECOVER_+((YieldReturn+WS)|(YieldBreak+WS)))
    // Only Nodes: (((YieldReturn)|(YieldBreak)))
    public class YieldStatement : CstSequence
    {
        public YieldStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new YieldStatement(Children.Select(f).ToArray());
        public CstChoice ChoiceRule => Children[0] as CstChoice;
    }

    // Original Rule: ("return"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS+EOS)
    // Only Nodes: (Expression)
    public class YieldReturn : CstSequence
    {
        public YieldReturn(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new YieldReturn(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("break"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    public class YieldBreak : CstNode
    {
        public YieldBreak(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new YieldBreak(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("continue"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    public class ContinueStatement : CstNode
    {
        public ContinueStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ContinueStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('{'+WS+_RECOVER_+((Statement+WS))*+'}'+WS)
    // Only Nodes: (((Statement))*)
    public class CompoundStatement : CstSequence
    {
        public CompoundStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CompoundStatement(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ("catch"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+VarDecl+WS+')'+WS+CompoundStatement+WS)
    // Only Nodes: (VarDecl+CompoundStatement)
    public class CatchClause : CstSequence
    {
        public CatchClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CatchClause(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public CompoundStatement CompoundStatement => Children[1] as CompoundStatement;
    }

    // Original Rule: ("finally"+!(IdentifierChar)+WS+CompoundStatement+WS)
    // Only Nodes: (CompoundStatement)
    public class FinallyClause : CstSequence
    {
        public FinallyClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FinallyClause(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
    }

    // Original Rule: ((("default"+!(IdentifierChar)+WS)|("case"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS))+(Statement+WS))
    // Only Nodes: (((Expression))+Statement)
    public class CaseClause : CstSequence
    {
        public CaseClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CaseClause(Children.Select(f).ToArray());
        public CstChoice ChoiceRule => Children[0] as CstChoice;
        public Statement Statement => Children[1] as Statement;
    }

    // Original Rule: ("switch"+!(IdentifierChar)+WS+_RECOVER_+'{'+WS+_RECOVER_+((CaseClause+WS))*+'}'+WS)
    // Only Nodes: (((CaseClause))*)
    public class SwitchStatement : CstSequence
    {
        public SwitchStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new SwitchStatement(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ("try"+!(IdentifierChar)+WS+_RECOVER_+CompoundStatement+WS+((CatchClause+WS))?+((FinallyClause+WS))?)
    // Only Nodes: (CompoundStatement+((CatchClause))?+((FinallyClause))?)
    public class TryStatement : CstSequence
    {
        public TryStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TryStatement(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
        public CstOptional<CstNode> SequenceRule => Children[1] as CstOptional<CstNode>;
        public CstOptional<CstNode> SequenceRule_1 => Children[2] as CstOptional<CstNode>;
    }

    // Original Rule: ("foreach"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+VarDecl+WS+"in"+!(IdentifierChar)+WS+Expression+WS+')'+WS+Statement+WS)
    // Only Nodes: (VarDecl+Expression+Statement)
    public class ForEachStatement : CstSequence
    {
        public ForEachStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ForEachStatement(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public Expression Expression => Children[1] as Expression;
        public Statement Statement => Children[2] as Statement;
    }

    // Original Rule: ((VarDecl+WS+Initialization+WS))?
    // Only Nodes: ((VarDecl+Initialization))?
    public class InitializationClause : CstNode
    {
        public InitializationClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new InitializationClause(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((Expression+WS))?
    // Only Nodes: ((Expression))?
    public class InvariantClause : CstNode
    {
        public InvariantClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new InvariantClause(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((Expression+WS))?
    // Only Nodes: ((Expression))?
    public class VariantClause : CstNode
    {
        public VariantClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new VariantClause(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ("for"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+InitializationClause+WS+EOS+InvariantClause+WS+EOS+VariantClause+WS+')'+WS+Statement+WS)
    // Only Nodes: (InitializationClause+InvariantClause+VariantClause+Statement)
    public class ForStatement : CstSequence
    {
        public ForStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ForStatement(Children.Select(f).ToArray());
        public InitializationClause InitializationClause => Children[0] as InitializationClause;
        public InvariantClause InvariantClause => Children[1] as InvariantClause;
        public VariantClause VariantClause => Children[2] as VariantClause;
        public Statement Statement => Children[3] as Statement;
    }

    // Original Rule: ('{'+WS+_RECOVER_+(((Expression+WS+WS+((Comma+Expression+WS+WS))*)+(Comma)?))?+'}'+WS)
    // Only Nodes: (((Expression+((Expression))*))?)
    public class ArrayInitializationValue : CstSequence
    {
        public ArrayInitializationValue(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ArrayInitializationValue(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((ArrayInitializationValue+WS)|(Expression+WS))
    // Only Nodes: ((ArrayInitializationValue)|(Expression))
    public class InitializationValue : CstChoice
    {
        public InitializationValue(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new InitializationValue(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: (('='+WS+_RECOVER_+InitializationValue+WS))?
    // Only Nodes: ((InitializationValue))?
    public class Initialization : CstNode
    {
        public Initialization(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Initialization(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS)
    // Only Nodes: (TypeExpr+Identifier)
    public class VarDecl : CstSequence
    {
        public VarDecl(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new VarDecl(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
    }

    // Original Rule: (VarDecl+WS+Initialization+WS+EOS)
    // Only Nodes: (VarDecl+Initialization)
    public class VarDeclStatement : CstSequence
    {
        public VarDeclStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new VarDeclStatement(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public Initialization Initialization => Children[1] as Initialization;
    }

    // Original Rule: (EOS|(CompoundStatement+WS)|(IfStatement+WS)|(WhileStatement+WS)|(DoWhileStatement+WS)|(ReturnStatement+WS)|(BreakStatement+WS)|(ContinueStatement+WS)|(ForStatement+WS)|(ForEachStatement+WS)|(VarDeclStatement+WS)|(TryStatement+WS)|(YieldStatement+WS)|(SwitchStatement+WS)|(ExpressionStatement+WS))
    // Only Nodes: ((CompoundStatement)|(IfStatement)|(WhileStatement)|(DoWhileStatement)|(ReturnStatement)|(BreakStatement)|(ContinueStatement)|(ForStatement)|(ForEachStatement)|(VarDeclStatement)|(TryStatement)|(YieldStatement)|(SwitchStatement)|(ExpressionStatement))
    public class Statement : CstChoice
    {
        public Statement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Statement(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
        public CstSequence SequenceRule_2 => Children[0] as CstSequence;
        public CstSequence SequenceRule_3 => Children[0] as CstSequence;
        public CstSequence SequenceRule_4 => Children[0] as CstSequence;
        public CstSequence SequenceRule_5 => Children[0] as CstSequence;
        public CstSequence SequenceRule_6 => Children[0] as CstSequence;
        public CstSequence SequenceRule_7 => Children[0] as CstSequence;
        public CstSequence SequenceRule_8 => Children[0] as CstSequence;
        public CstSequence SequenceRule_9 => Children[0] as CstSequence;
        public CstSequence SequenceRule_10 => Children[0] as CstSequence;
        public CstSequence SequenceRule_11 => Children[0] as CstSequence;
        public CstSequence SequenceRule_12 => Children[0] as CstSequence;
        public CstSequence SequenceRule_13 => Children[0] as CstSequence;
    }

    // Original Rule: (((Identifier+WS+WS+(('.'+WS+Identifier+WS+WS))*)+(('.'+WS))?))?
    // Only Nodes: ((Identifier+((Identifier))*))?
    public class QualifiedIdentifier : CstNode
    {
        public QualifiedIdentifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new QualifiedIdentifier(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (("static"+!(IdentifierChar)+WS))?
    // Only Nodes: 
    public class Static : CstNode
    {
        public Static(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Static(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("global"+!(IdentifierChar)+WS))?+"using"+!(IdentifierChar)+WS+_RECOVER_+Static+WS+QualifiedIdentifier+WS+EOS)
    // Only Nodes: (Static+QualifiedIdentifier)
    public class UsingDirective : CstSequence
    {
        public UsingDirective(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new UsingDirective(Children.Select(f).ToArray());
        public Static Static => Children[0] as Static;
        public QualifiedIdentifier QualifiedIdentifier => Children[1] as QualifiedIdentifier;
    }

    // Original Rule: (("readonly"+!(IdentifierChar)+WS)|("abstract"+!(IdentifierChar)+WS)|("partial"+!(IdentifierChar)+WS)|("virtual"+!(IdentifierChar)+WS)|("static"+!(IdentifierChar)+WS)|("sealed"+!(IdentifierChar)+WS)|("const"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class Modifier : CstNode
    {
        public Modifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Modifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("protected"+!(IdentifierChar)+WS)|("internal"+!(IdentifierChar)+WS)|("private"+!(IdentifierChar)+WS)|("public"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class AccessSpecifier : CstNode
    {
        public AccessSpecifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new AccessSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('['+WS+(((Identifier+WS+((FunctionArgs+WS))?+WS+((Comma+Identifier+WS+((FunctionArgs+WS))?+WS))*)+(Comma)?))?+']'+WS)
    // Only Nodes: (((Identifier+((FunctionArgs))?+((Identifier+((FunctionArgs))?))*))?)
    public class Attribute : CstSequence
    {
        public Attribute(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Attribute(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((Attribute+WS))*
    // Only Nodes: ((Attribute))*
    public class AttributeList : CstNode
    {
        public AttributeList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new AttributeList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (AttributeList+WS+(((Modifier+WS)|(AccessSpecifier+WS)))*)
    // Only Nodes: (AttributeList+(((Modifier)|(AccessSpecifier)))*)
    public class DeclarationPreamble : CstSequence
    {
        public DeclarationPreamble(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new DeclarationPreamble(Children.Select(f).ToArray());
        public AttributeList AttributeList => Children[0] as AttributeList;
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleChoiceRule => Children[1] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ((("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS)))?
    // Only Nodes: 
    public class TypeVariance : CstNode
    {
        public TypeVariance(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeVariance(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (TypeVariance+WS+Identifier+WS)
    // Only Nodes: (TypeVariance+Identifier)
    public class TypeParameter : CstSequence
    {
        public TypeParameter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeParameter(Children.Select(f).ToArray());
        public TypeVariance TypeVariance => Children[0] as TypeVariance;
        public Identifier Identifier => Children[1] as Identifier;
    }

    // Original Rule: (('<'+WS+(((TypeParameter+WS+WS+((Comma+TypeParameter+WS+WS))*)+(Comma)?))?+'>'+WS))?
    // Only Nodes: ((((TypeParameter+((TypeParameter))*))?))?
    public class TypeParameterList : CstNode
    {
        public TypeParameterList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeParameterList(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((':'+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?))?
    // Only Nodes: ((((TypeExpr+((TypeExpr))*))?))?
    public class BaseClassList : CstNode
    {
        public BaseClassList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BaseClassList(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (("class"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|(TypeExpr+WS))
    // Only Nodes: ((TypeExpr))
    public class Constraint : CstChoice
    {
        public Constraint(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Constraint(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
    }

    // Original Rule: ("where"+!(IdentifierChar)+WS+Identifier+WS+':'+WS+TypeExpr+WS)
    // Only Nodes: (Identifier+TypeExpr)
    public class ConstraintClause : CstSequence
    {
        public ConstraintClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ConstraintClause(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
        public TypeExpr TypeExpr => Children[1] as TypeExpr;
    }

    // Original Rule: ((ConstraintClause+WS))*
    // Only Nodes: ((ConstraintClause))*
    public class ConstraintList : CstNode
    {
        public ConstraintList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ConstraintList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (("interface"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|("class"+!(IdentifierChar)+WS)|("enum"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class Kind : CstNode
    {
        public Kind(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Kind(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (Kind+WS+_RECOVER_+Identifier+WS+TypeParameterList+WS+BaseClassList+WS+ConstraintList+WS+'{'+WS+_RECOVER_+((MemberDeclaration+WS))*+'}'+WS)
    // Only Nodes: (Kind+Identifier+TypeParameterList+BaseClassList+ConstraintList+((MemberDeclaration))*)
    public class TypeDeclaration : CstSequence
    {
        public TypeDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeDeclaration(Children.Select(f).ToArray());
        public Kind Kind => Children[0] as Kind;
        public Identifier Identifier => Children[1] as Identifier;
        public TypeParameterList TypeParameterList => Children[2] as TypeParameterList;
        public BaseClassList BaseClassList => Children[3] as BaseClassList;
        public ConstraintList ConstraintList => Children[4] as ConstraintList;
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[5] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (DeclarationPreamble+WS+TypeDeclaration+WS)
    // Only Nodes: (DeclarationPreamble+TypeDeclaration)
    public class TypeDeclarationWithPreamble : CstSequence
    {
        public TypeDeclarationWithPreamble(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeDeclarationWithPreamble(Children.Select(f).ToArray());
        public DeclarationPreamble DeclarationPreamble => Children[0] as DeclarationPreamble;
        public TypeDeclaration TypeDeclaration => Children[1] as TypeDeclaration;
    }

    // Original Rule: ((("params"+!(IdentifierChar)+WS)|("this"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS)|("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS)))?
    // Only Nodes: 
    public class FunctionParameterKeywords : CstNode
    {
        public FunctionParameterKeywords(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FunctionParameterKeywords(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (('='+WS+Expression+WS))?
    // Only Nodes: ((Expression))?
    public class DefaultValue : CstNode
    {
        public DefaultValue(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new DefaultValue(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (AttributeList+WS+FunctionParameterKeywords+WS+TypeExpr+WS+Identifier+WS+DefaultValue+WS)
    // Only Nodes: (AttributeList+FunctionParameterKeywords+TypeExpr+Identifier+DefaultValue)
    public class FunctionParameter : CstSequence
    {
        public FunctionParameter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FunctionParameter(Children.Select(f).ToArray());
        public AttributeList AttributeList => Children[0] as AttributeList;
        public FunctionParameterKeywords FunctionParameterKeywords => Children[1] as FunctionParameterKeywords;
        public TypeExpr TypeExpr => Children[2] as TypeExpr;
        public Identifier Identifier => Children[3] as Identifier;
        public DefaultValue DefaultValue => Children[4] as DefaultValue;
    }

    // Original Rule: ('('+WS+(((FunctionParameter+WS+WS+((Comma+FunctionParameter+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((FunctionParameter+((FunctionParameter))*))?)
    public class FunctionParameterList : CstSequence
    {
        public FunctionParameterList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FunctionParameterList(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ("=>"+WS+_RECOVER_+((Expression+WS+EOS)|(CompoundStatement+WS)))
    // Only Nodes: (((Expression)|(CompoundStatement)))
    public class ExpressionBody : CstSequence
    {
        public ExpressionBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ExpressionBody(Children.Select(f).ToArray());
        public CstChoice ChoiceRule => Children[0] as CstChoice;
    }

    // Original Rule: ((ExpressionBody+WS)|(CompoundStatement+WS)|EOS)
    // Only Nodes: ((ExpressionBody)|(CompoundStatement))
    public class FunctionBody : CstChoice
    {
        public FunctionBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FunctionBody(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: ("base"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS)
    // Only Nodes: (ParenthesizedExpression)
    public class BaseCall : CstSequence
    {
        public BaseCall(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BaseCall(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: ("this"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS)
    // Only Nodes: (ParenthesizedExpression)
    public class ThisCall : CstSequence
    {
        public ThisCall(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ThisCall(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: ((':'+WS+((BaseCall+WS)|(ThisCall+WS))))?
    // Only Nodes: ((((BaseCall)|(ThisCall))))?
    public class BaseOrThisCall : CstNode
    {
        public BaseOrThisCall(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BaseOrThisCall(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (Identifier+WS+FunctionParameterList+WS+_RECOVER_+BaseOrThisCall+WS+FunctionBody+WS)
    // Only Nodes: (Identifier+FunctionParameterList+BaseOrThisCall+FunctionBody)
    public class ConstructorDeclaration : CstSequence
    {
        public ConstructorDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ConstructorDeclaration(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
        public FunctionParameterList FunctionParameterList => Children[1] as FunctionParameterList;
        public BaseOrThisCall BaseOrThisCall => Children[2] as BaseOrThisCall;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+FunctionParameterList+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (TypeExpr+Identifier+FunctionParameterList+FunctionBody)
    public class MethodDeclaration : CstSequence
    {
        public MethodDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new MethodDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public FunctionParameterList FunctionParameterList => Children[2] as FunctionParameterList;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+((Initialization+WS))?+EOS)
    // Only Nodes: (TypeExpr+Identifier+((Initialization))?)
    public class FieldDeclaration : CstSequence
    {
        public FieldDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FieldDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public CstOptional<CstNode> SequenceRule => Children[2] as CstOptional<CstNode>;
    }

    // Original Rule: ("get"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (FunctionBody)
    public class Getter : CstSequence
    {
        public Getter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Getter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: ("set"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (FunctionBody)
    public class Setter : CstSequence
    {
        public Setter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Setter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: ("init"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (FunctionBody)
    public class Initter : CstSequence
    {
        public Initter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Initter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: (((Getter+WS)|(Setter+WS)|(Initter+WS)))*
    // Only Nodes: (((Getter)|(Setter)|(Initter)))*
    public class PropertyClauses : CstNode
    {
        public PropertyClauses(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new PropertyClauses(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleChoiceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ((ExpressionBody+WS)|('{'+WS+_RECOVER_+PropertyClauses+WS+'}'+WS))
    // Only Nodes: ((ExpressionBody)|(PropertyClauses))
    public class PropertyBody : CstChoice
    {
        public PropertyBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new PropertyBody(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+PropertyBody+WS)
    // Only Nodes: (TypeExpr+Identifier+PropertyBody)
    public class PropertyDeclaration : CstSequence
    {
        public PropertyDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new PropertyDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public PropertyBody PropertyBody => Children[2] as PropertyBody;
    }

    // Original Rule: (TypeExpr+WS+"this"+!(IdentifierChar)+WS+_RECOVER_+'['+WS+FunctionParameter+WS+']'+WS+PropertyBody+WS)
    // Only Nodes: (TypeExpr+FunctionParameter+PropertyBody)
    public class IndexerDeclaration : CstSequence
    {
        public IndexerDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new IndexerDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public FunctionParameter FunctionParameter => Children[1] as FunctionParameter;
        public PropertyBody PropertyBody => Children[2] as PropertyBody;
    }

    // Original Rule: (TypeExpr+WS+"operator"+!(IdentifierChar)+WS+_RECOVER_+OverloadableOperator+WS+FunctionParameterList+WS+FunctionBody+WS)
    // Only Nodes: (TypeExpr+OverloadableOperator+FunctionParameterList+FunctionBody)
    public class OperatorDeclaration : CstSequence
    {
        public OperatorDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new OperatorDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public OverloadableOperator OverloadableOperator => Children[1] as OverloadableOperator;
        public FunctionParameterList FunctionParameterList => Children[2] as FunctionParameterList;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (("implicit"+!(IdentifierChar)+WS)|("explicit"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class ImplicitOrExplicit : CstNode
    {
        public ImplicitOrExplicit(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ImplicitOrExplicit(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (TypeExpr+WS+ImplicitOrExplicit+WS+"operator"+!(IdentifierChar)+WS+TypeExpr+WS+FunctionBody+WS)
    // Only Nodes: (TypeExpr+ImplicitOrExplicit+TypeExpr+FunctionBody)
    public class ConverterDeclaration : CstSequence
    {
        public ConverterDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ConverterDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public ImplicitOrExplicit ImplicitOrExplicit => Children[1] as ImplicitOrExplicit;
        public TypeExpr TypeExpr_1 => Children[2] as TypeExpr;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (DeclarationPreamble+WS+((ConstructorDeclaration+WS)|(MethodDeclaration+WS)|(IndexerDeclaration+WS)|(PropertyDeclaration+WS)|(FieldDeclaration+WS)|(OperatorDeclaration+WS)|(ConverterDeclaration+WS)|(TypeDeclaration+WS)))
    // Only Nodes: (DeclarationPreamble+((ConstructorDeclaration)|(MethodDeclaration)|(IndexerDeclaration)|(PropertyDeclaration)|(FieldDeclaration)|(OperatorDeclaration)|(ConverterDeclaration)|(TypeDeclaration)))
    public class MemberDeclaration : CstSequence
    {
        public MemberDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new MemberDeclaration(Children.Select(f).ToArray());
        public DeclarationPreamble DeclarationPreamble => Children[0] as DeclarationPreamble;
        public CstChoice ChoiceRule => Children[1] as CstChoice;
    }

    // Original Rule: ("namespace"+!(IdentifierChar)+WS+_RECOVER_+QualifiedIdentifier+WS+'{'+WS+_RECOVER_+((TypeDeclarationWithPreamble+WS))*+'}'+WS)
    // Only Nodes: (QualifiedIdentifier+((TypeDeclarationWithPreamble))*)
    public class NamespaceDeclaration : CstSequence
    {
        public NamespaceDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new NamespaceDeclaration(Children.Select(f).ToArray());
        public QualifiedIdentifier QualifiedIdentifier => Children[0] as QualifiedIdentifier;
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[1] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (WS+((UsingDirective+WS))*+((NamespaceDeclaration+WS))?)
    // Only Nodes: (((UsingDirective))*+((NamespaceDeclaration))?)
    public class File : CstSequence
    {
        public File(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new File(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
        public CstOptional<CstNode> SequenceRule => Children[1] as CstOptional<CstNode>;
    }

    // Original Rule: ('['+WS+(Comma)*+']'+WS)
    // Only Nodes: 
    public class ArrayRankSpecifier : CstNode
    {
        public ArrayRankSpecifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ArrayRankSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((ArrayRankSpecifier+WS))*
    // Only Nodes: ((ArrayRankSpecifier))*
    public class ArrayRankSpecifiers : CstNode
    {
        public ArrayRankSpecifiers(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ArrayRankSpecifiers(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ('<'+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?+'>'+WS)
    // Only Nodes: (((TypeExpr+((TypeExpr))*))?)
    public class TypeArgList : CstSequence
    {
        public TypeArgList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeArgList(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (('?'+WS))?
    // Only Nodes: 
    public class Nullable : CstNode
    {
        public Nullable(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Nullable(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('('+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((TypeExpr+((TypeExpr))*))?)
    public class CompoundTypeExpr : CstSequence
    {
        public CompoundTypeExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CompoundTypeExpr(Children.Select(f).ToArray());
        public CstOptional<CstNode> SequenceRule => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (((CompoundTypeExpr+WS)|SimpleTypExpr)+((TypeArgList+WS))?+ArrayRankSpecifiers+WS)
    // Only Nodes: (((CompoundTypeExpr)|(QualifiedIdentifier))+((TypeArgList))?+ArrayRankSpecifiers)
    public class InnerTypeExpr : CstSequence
    {
        public InnerTypeExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new InnerTypeExpr(Children.Select(f).ToArray());
        public CstChoice ChoiceRule => Children[0] as CstChoice;
        public CstOptional<CstNode> SequenceRule => Children[1] as CstOptional<CstNode>;
        public ArrayRankSpecifiers ArrayRankSpecifiers => Children[2] as ArrayRankSpecifiers;
    }

    // Original Rule: (InnerTypeExpr+WS)
    // Only Nodes: (InnerTypeExpr)
    public class TypeExpr : CstSequence
    {
        public TypeExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeExpr(Children.Select(f).ToArray());
        public InnerTypeExpr InnerTypeExpr => Children[0] as InnerTypeExpr;
    }

    // Original Rule: ([\x2C\x2E\x3B]|(TypeKeyword+WS)|(StatementKeyword+WS))
    // Only Nodes: ((TypeKeyword)|(StatementKeyword))
    public class Separator : CstChoice
    {
        public Separator(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Separator(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: (("interface"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|("class"+!(IdentifierChar)+WS)|("enum"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class TypeKeyword : CstNode
    {
        public TypeKeyword(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("continue"+!(IdentifierChar)+WS)|("foreach"+!(IdentifierChar)+WS)|("finally"+!(IdentifierChar)+WS)|("default"+!(IdentifierChar)+WS)|("return"+!(IdentifierChar)+WS)|("switch"+!(IdentifierChar)+WS)|("break"+!(IdentifierChar)+WS)|("throw"+!(IdentifierChar)+WS)|("catch"+!(IdentifierChar)+WS)|("using"+!(IdentifierChar)+WS)|("case"+!(IdentifierChar)+WS)|("for"+!(IdentifierChar)+WS)|("try"+!(IdentifierChar)+WS)|("if"+!(IdentifierChar)+WS)|("do"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class StatementKeyword : CstNode
    {
        public StatementKeyword(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new StatementKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((Separator+WS)|CppStyleComment|Spaces|([\x21\x23-\x26\x2A+\x2D\x2F\x3A<-\x40^|~]+([\x21\x23-\x26\x2A+\x2D\x2F\x3A<-\x40^|~])*)|(Identifier+WS)|(Literal+WS))
    // Only Nodes: ((Separator)|(Identifier)|(Literal))
    public class Token : CstChoice
    {
        public Token(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Token(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
        public CstSequence SequenceRule_2 => Children[0] as CstSequence;
    }

    // Original Rule: ((!([\x28\x29\x5B\x5D\x7B\x7D])+((Token+WS)|(Separator+WS)))+((!([\x28\x29\x5B\x5D\x7B\x7D])+((Token+WS)|(Separator+WS))))*)
    // Only Nodes: (((Token)|(Separator))+((((Token)|(Separator))))*)
    public class TokenGroup : CstSequence
    {
        public TokenGroup(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TokenGroup(Children.Select(f).ToArray());
        public CstChoice ChoiceRule => Children[0] as CstChoice;
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[1] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (TypeKeyword+WS+TokenGroup+WS+BracedStructure+WS)
    // Only Nodes: (TypeKeyword+TokenGroup+BracedStructure)
    public class TypeStructure : CstSequence
    {
        public TypeStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new TypeStructure(Children.Select(f).ToArray());
        public TypeKeyword TypeKeyword => Children[0] as TypeKeyword;
        public TokenGroup TokenGroup => Children[1] as TokenGroup;
        public BracedStructure BracedStructure => Children[2] as BracedStructure;
    }

    // Original Rule: (StatementKeyword+WS+TokenGroup+WS+((BracedStructure+WS))?)
    // Only Nodes: (StatementKeyword+TokenGroup+((BracedStructure))?)
    public class StatementStructure : CstSequence
    {
        public StatementStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new StatementStructure(Children.Select(f).ToArray());
        public StatementKeyword StatementKeyword => Children[0] as StatementKeyword;
        public TokenGroup TokenGroup => Children[1] as TokenGroup;
        public CstOptional<CstNode> SequenceRule => Children[2] as CstOptional<CstNode>;
    }

    // Original Rule: ((Structure+WS)|(TokenGroup+WS))
    // Only Nodes: ((Structure)|(TokenGroup))
    public class Element : CstChoice
    {
        public Element(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Element(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
    }

    // Original Rule: ('{'+((Element+WS))*+'}')
    // Only Nodes: (((Element))*)
    public class BracedStructure : CstSequence
    {
        public BracedStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BracedStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ('['+((Element+WS))*+']')
    // Only Nodes: (((Element))*)
    public class BracketedStructure : CstSequence
    {
        public BracketedStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new BracketedStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ('('+((Element+WS))*+')')
    // Only Nodes: (((Element))*)
    public class ParenthesizedStructure : CstSequence
    {
        public ParenthesizedStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new ParenthesizedStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ((BracketedStructure+WS)|(ParenthesizedStructure+WS)|(BracedStructure+WS))
    // Only Nodes: ((BracketedStructure)|(ParenthesizedStructure)|(BracedStructure))
    public class Structure : CstChoice
    {
        public Structure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new Structure(Children.Select(f).ToArray());
        public CstSequence SequenceRule => Children[0] as CstSequence;
        public CstSequence SequenceRule_1 => Children[0] as CstSequence;
        public CstSequence SequenceRule_2 => Children[0] as CstSequence;
    }

    // Original Rule: ((Element+WS))*
    // Only Nodes: ((Element))*
    public class FileStructure : CstNode
    {
        public FileStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new FileStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstNode> ZeroOrMoreRuleSequenceRule => Children[0] as CstZeroOrMore<CstNode>;
    }

}
