// DO NOT EDIT: Autogenerated file created on 2023-04-19 11:03:00 PM. 
using System;
using System.Linq;
using Parakeet;

namespace Parakeet.Demos.Pail
{
    // Original Rule: ((Break+WS)|(Continue+WS)|(Noop+WS)|(Loop+WS)|(Return+WS)|(Conditional+WS)|(VarDef+WS)|(Block+WS)|(Lambda+WS)|(ParenthesizedExpr+WS)|(Constant+WS)|(Invoke+WS)|(Assign+WS)|(VarRef+WS))
    // Only Nodes: (Break|Continue|Noop|Loop|Return|Conditional|VarDef|Block|Lambda|ParenthesizedExpr|Constant|Invoke|Assign|VarRef)
    // Optimized only nodes: (Break|Continue|Noop|Loop|Return|Conditional|VarDef|Block|Lambda|ParenthesizedExpr|Constant|Invoke|Assign|VarRef)
    public class CstExpr : CstChoice
    {
        public CstExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstExpr(Children.Select(f).ToArray());
        public CstBreak Break => Children[0] as CstBreak;
        public CstContinue Continue => Children[0] as CstContinue;
        public CstNoop Noop => Children[0] as CstNoop;
        public CstLoop Loop => Children[0] as CstLoop;
        public CstReturn Return => Children[0] as CstReturn;
        public CstConditional Conditional => Children[0] as CstConditional;
        public CstVarDef VarDef => Children[0] as CstVarDef;
        public CstBlock Block => Children[0] as CstBlock;
        public CstLambda Lambda => Children[0] as CstLambda;
        public CstParenthesizedExpr ParenthesizedExpr => Children[0] as CstParenthesizedExpr;
        public CstConstant Constant => Children[0] as CstConstant;
        public CstInvoke Invoke => Children[0] as CstInvoke;
        public CstAssign Assign => Children[0] as CstAssign;
        public CstVarRef VarRef => Children[0] as CstVarRef;
    }

    // Original Rule: ('('+WS+Expr+WS+')'+WS)
    // Only Nodes: Expr
    // Optimized only nodes: Expr
    public class CstParenthesizedExpr : CstNode
    {
        public CstParenthesizedExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstParenthesizedExpr(Children.Select(f).ToArray());
        public CstExpr Expr => Children[0] as CstExpr;
    }

    // Original Rule: ('('+WS+(((Expr+WS+WS+((Comma+Expr+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: ((Expr+(Expr)*))?
    // Optimized only nodes: (Expr)*
    public class CstArgs : CstNode
    {
        public CstArgs(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstArgs(Children.Select(f).ToArray());
        public CstZeroOrMore<CstExpr> Expr => Children[0] as CstZeroOrMore<CstExpr>;
    }

    // Original Rule: (VarRef+WS+Args+WS)
    // Only Nodes: (VarRef+Args)
    // Optimized only nodes: (VarRef+Args)
    public class CstInvoke : CstSequence
    {
        public CstInvoke(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInvoke(Children.Select(f).ToArray());
        public CstVarRef VarRef => Children[0] as CstVarRef;
        public CstArgs Args => Children[1] as CstArgs;
    }

    // Original Rule: (VarRef+WS+'='+WS+_RECOVER_+Expr+WS)
    // Only Nodes: (VarRef+Expr)
    // Optimized only nodes: (VarRef+Expr)
    public class CstAssign : CstSequence
    {
        public CstAssign(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstAssign(Children.Select(f).ToArray());
        public CstVarRef VarRef => Children[0] as CstVarRef;
        public CstExpr Expr => Children[1] as CstExpr;
    }

    // Original Rule: (Identifier+WS)
    // Only Nodes: Identifier
    // Optimized only nodes: Identifier
    public class CstVarRef : CstNode
    {
        public CstVarRef(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstVarRef(Children.Select(f).ToArray());
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
    }

    // Original Rule: ("let"+!(IdentifierChar)+WS+_RECOVER_+Identifier+WS+'='+!(IdentifierChar)+WS+Expr+WS)
    // Only Nodes: (Identifier+Expr)
    // Optimized only nodes: (Identifier+Expr)
    public class CstVarDef : CstSequence
    {
        public CstVarDef(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstVarDef(Children.Select(f).ToArray());
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
        public CstExpr Expr => Children[1] as CstExpr;
    }

    // Original Rule: ("if"+!(IdentifierChar)+WS+_RECOVER_+Expr+WS+"then"+!(IdentifierChar)+WS+Expr+WS+"else"+!(IdentifierChar)+WS+Expr+WS)
    // Only Nodes: (Expr+Expr+Expr)
    // Optimized only nodes: (Expr+Expr+Expr)
    public class CstConditional : CstSequence
    {
        public CstConditional(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConditional(Children.Select(f).ToArray());
        public CstExpr Expr => Children[0] as CstExpr;
        public CstExpr Expr_1 => Children[1] as CstExpr;
        public CstExpr Expr_2 => Children[2] as CstExpr;
    }

    // Original Rule: ("while"+!(IdentifierChar)+WS+_RECOVER_+Expr+WS+"do"+!(IdentifierChar)+WS+Expr+WS)
    // Only Nodes: (Expr+Expr)
    // Optimized only nodes: (Expr+Expr)
    public class CstLoop : CstSequence
    {
        public CstLoop(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLoop(Children.Select(f).ToArray());
        public CstExpr Expr => Children[0] as CstExpr;
        public CstExpr Expr_1 => Children[1] as CstExpr;
    }

    // Original Rule: ('{'+WS+_RECOVER_+(((Expr+WS)+(';'+WS)))*+'}'+WS)
    // Only Nodes: (Expr)*
    // Optimized only nodes: (Expr)*
    public class CstBlock : CstNode
    {
        public CstBlock(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBlock(Children.Select(f).ToArray());
        public CstZeroOrMore<CstExpr> Expr => Children[0] as CstZeroOrMore<CstExpr>;
    }

    // Original Rule: (Literal+WS)
    // Only Nodes: Literal
    // Optimized only nodes: Literal
    public class CstConstant : CstNode
    {
        public CstConstant(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConstant(Children.Select(f).ToArray());
        public CstLiteral Literal => Children[0] as CstLiteral;
    }

    // Original Rule: ("break"+!(IdentifierChar)+WS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstBreak : CstLeaf
    {
        public CstBreak(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBreak(Text);
        // No children
    }

    // Original Rule: ("continue"+!(IdentifierChar)+WS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstContinue : CstLeaf
    {
        public CstContinue(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstContinue(Text);
        // No children
    }

    // Original Rule: ("return"+!(IdentifierChar)+WS+_RECOVER_+Expr+WS)
    // Only Nodes: Expr
    // Optimized only nodes: Expr
    public class CstReturn : CstNode
    {
        public CstReturn(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstReturn(Children.Select(f).ToArray());
        public CstExpr Expr => Children[0] as CstExpr;
    }

    // Original Rule: ('_'+!(IdentifierChar)+WS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstNoop : CstLeaf
    {
        public CstNoop(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstNoop(Text);
        // No children
    }

    // Original Rule: ('('+WS+(((Identifier+WS+WS+((Comma+Identifier+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: ((Identifier+(Identifier)*))?
    // Optimized only nodes: (Identifier)*
    public class CstParameters : CstNode
    {
        public CstParameters(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstParameters(Children.Select(f).ToArray());
        public CstZeroOrMore<CstIdentifier> Identifier => Children[0] as CstZeroOrMore<CstIdentifier>;
    }

    // Original Rule: (Parameters+WS+"=>"+WS+_RECOVER_+Expr+WS)
    // Only Nodes: (Parameters+Expr)
    // Optimized only nodes: (Parameters+Expr)
    public class CstLambda : CstSequence
    {
        public CstLambda(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLambda(Children.Select(f).ToArray());
        public CstParameters Parameters => Children[0] as CstParameters;
        public CstExpr Expr => Children[1] as CstExpr;
    }

    // Original Rule: (('-')?+Digits+(FractionalPart)?+(ExponentPart)?+(FloatSuffix)?)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstFloatLiteral : CstLeaf
    {
        public CstFloatLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFloatLiteral(Text);
        // No children
    }

    // Original Rule: (("0x"|"0X")+(HexDigit)++(IntegerSuffix)?)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstHexLiteral : CstLeaf
    {
        public CstHexLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstHexLiteral(Text);
        // No children
    }

    // Original Rule: ("0b"|("0B"+(BinDigit)++(IntegerSuffix)?))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstBinaryLiteral : CstLeaf
    {
        public CstBinaryLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBinaryLiteral(Text);
        // No children
    }

    // Original Rule: (Digits+!([\x2EDFMdfm])+(IntegerSuffix)?)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstIntegerLiteral : CstLeaf
    {
        public CstIntegerLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstIntegerLiteral(Text);
        // No children
    }

    // Original Rule: (('@')?+'"'+(StringLiteralChar)*+'"')
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstStringLiteral : CstLeaf
    {
        public CstStringLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStringLiteral(Text);
        // No children
    }

    // Original Rule: ('''+CharLiteralChar+''')
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstCharLiteral : CstLeaf
    {
        public CstCharLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstCharLiteral(Text);
        // No children
    }

    // Original Rule: (("true"+!(IdentifierChar)+WS)|("false"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstBooleanLiteral : CstLeaf
    {
        public CstBooleanLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBooleanLiteral(Text);
        // No children
    }

    // Original Rule: ("null"+!(IdentifierChar)+WS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstNullLiteral : CstLeaf
    {
        public CstNullLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstNullLiteral(Text);
        // No children
    }

    // Original Rule: ("value"+!(IdentifierChar)+WS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstValueLiteral : CstLeaf
    {
        public CstValueLiteral(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstValueLiteral(Text);
        // No children
    }

    // Original Rule: ((HexLiteral+WS)|(BinaryLiteral+WS)|(FloatLiteral+WS)|(IntegerLiteral+WS)|(StringLiteral+WS)|(CharLiteral+WS)|(BooleanLiteral+WS)|(NullLiteral+WS)|(ValueLiteral+WS))
    // Only Nodes: (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral|ValueLiteral)
    // Optimized only nodes: (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral|ValueLiteral)
    public class CstLiteral : CstChoice
    {
        public CstLiteral(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLiteral(Children.Select(f).ToArray());
        public CstHexLiteral HexLiteral => Children[0] as CstHexLiteral;
        public CstBinaryLiteral BinaryLiteral => Children[0] as CstBinaryLiteral;
        public CstFloatLiteral FloatLiteral => Children[0] as CstFloatLiteral;
        public CstIntegerLiteral IntegerLiteral => Children[0] as CstIntegerLiteral;
        public CstStringLiteral StringLiteral => Children[0] as CstStringLiteral;
        public CstCharLiteral CharLiteral => Children[0] as CstCharLiteral;
        public CstBooleanLiteral BooleanLiteral => Children[0] as CstBooleanLiteral;
        public CstNullLiteral NullLiteral => Children[0] as CstNullLiteral;
        public CstValueLiteral ValueLiteral => Children[0] as CstValueLiteral;
    }

    // Original Rule: ((">>>="+WS)|(">>>"+WS)|(">>="+WS)|("<<="+WS)|("\x26\x26="+WS)|("||="+WS)|(">>"+WS)|("<<"+WS)|("\x26\x26"+WS)|("||"+WS)|("+="+WS)|("\x2D="+WS)|("\x2A="+WS)|("\x2F="+WS)|("\x25="+WS)|("\x26="+WS)|("|="+WS)|("^="+WS)|("<="+WS)|(">="+WS)|("=="+WS)|("\x21="+WS)|("\x3F\x3F"+WS)|("\x3F="+WS)|('+'+WS)|('-'+WS)|('*'+WS)|('/'+WS)|('%'+WS)|('&'+WS)|('|'+WS)|('^'+WS)|('='+WS)|('<'+WS)|('>'+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstBinaryOperator : CstLeaf
    {
        public CstBinaryOperator(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBinaryOperator(Text);
        // No children
    }

    // Original Rule: ('('+WS+TypeExpr+WS+')'+WS+Expression+WS)
    // Only Nodes: (TypeExpr+Expression)
    // Optimized only nodes: (TypeExpr+Expression)
    public class CstCastExpression : CstSequence
    {
        public CstCastExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstCastExpression(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstExpression Expression => Children[1] as CstExpression;
    }

    // Original Rule: (("++"+WS)|("\x2D\x2D"+WS)|('!'+WS)|('-'+WS)|('+'+WS)|('~'+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstUnaryOperator : CstLeaf
    {
        public CstUnaryOperator(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstUnaryOperator(Text);
        // No children
    }

    // Original Rule: ('['+WS+Expression+WS+']'+WS)
    // Only Nodes: Expression
    // Optimized only nodes: Expression
    public class CstIndexer : CstNode
    {
        public CstIndexer(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstIndexer(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: ((">>>"+WS)|("++"+WS)|("\x2D\x2D"+WS)|("<<"+WS)|(">>"+WS)|("=="+WS)|("\x21="+WS)|("<="+WS)|(">="+WS)|('+'+WS)|('-'+WS)|('!'+WS)|('~'+WS)|('*'+WS)|('/'+WS)|('%'+WS)|('&'+WS)|('|'+WS)|('^'+WS)|('<'+WS)|('>'+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstOverloadableOperator : CstLeaf
    {
        public CstOverloadableOperator(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstOverloadableOperator(Text);
        // No children
    }

    // Original Rule: (("++"+WS)|("\x2D\x2D"+WS)|('!'+WS)|(MemberAccess+WS)|(ConditionalMemberAccess+WS)|(FunctionArgs+WS)|(Indexer+WS)|(TernaryOperation+WS)|(BinaryOperation+WS)|(IsOperation+WS)|(AsOperation+WS))
    // Only Nodes: (MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)
    // Optimized only nodes: (MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)
    public class CstPostfixOperator : CstChoice
    {
        public CstPostfixOperator(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstPostfixOperator(Children.Select(f).ToArray());
        public CstMemberAccess MemberAccess => Children[0] as CstMemberAccess;
        public CstConditionalMemberAccess ConditionalMemberAccess => Children[0] as CstConditionalMemberAccess;
        public CstFunctionArgs FunctionArgs => Children[0] as CstFunctionArgs;
        public CstIndexer Indexer => Children[0] as CstIndexer;
        public CstTernaryOperation TernaryOperation => Children[0] as CstTernaryOperation;
        public CstBinaryOperation BinaryOperation => Children[0] as CstBinaryOperation;
        public CstIsOperation IsOperation => Children[0] as CstIsOperation;
        public CstAsOperation AsOperation => Children[0] as CstAsOperation;
    }

    // Original Rule: (IdentifierFirstChar+(IdentifierChar)*)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstIdentifier : CstLeaf
    {
        public CstIdentifier(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstIdentifier(Text);
        // No children
    }

    // Original Rule: (!("=>")+BinaryOperator+WS+_RECOVER_+Expression+WS)
    // Only Nodes: (BinaryOperator+Expression)
    // Optimized only nodes: (BinaryOperator+Expression)
    public class CstBinaryOperation : CstSequence
    {
        public CstBinaryOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBinaryOperation(Children.Select(f).ToArray());
        public CstBinaryOperator BinaryOperator => Children[0] as CstBinaryOperator;
        public CstExpression Expression => Children[1] as CstExpression;
    }

    // Original Rule: ('?'+WS+_RECOVER_+Expression+WS+':'+WS+Expression+WS)
    // Only Nodes: (Expression+Expression)
    // Optimized only nodes: (Expression+Expression)
    public class CstTernaryOperation : CstSequence
    {
        public CstTernaryOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTernaryOperation(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
        public CstExpression Expression_1 => Children[1] as CstExpression;
    }

    // Original Rule: ('('+WS+(((Expression+WS+WS+((Comma+Expression+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: ((Expression+(Expression)*))?
    // Optimized only nodes: (Expression)*
    public class CstParenthesizedExpression : CstNode
    {
        public CstParenthesizedExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstParenthesizedExpression(Children.Select(f).ToArray());
        public CstZeroOrMore<CstExpression> Expression => Children[0] as CstZeroOrMore<CstExpression>;
    }

    // Original Rule: ("throw"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS)
    // Only Nodes: Expression
    // Optimized only nodes: Expression
    public class CstThrowExpression : CstNode
    {
        public CstThrowExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstThrowExpression(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: ((TypeExpr+WS+Identifier+WS)|(Identifier+WS))
    // Only Nodes: ((TypeExpr+Identifier)|Identifier)
    // Optimized only nodes: ((TypeExpr)?+Identifier)
    public class CstLambdaParameter : CstSequence
    {
        public CstLambdaParameter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLambdaParameter(Children.Select(f).ToArray());
        public CstOptional<CstTypeExpr> TypeExpr => Children[0] as CstOptional<CstTypeExpr>;
        public CstIdentifier Identifier => Children[1] as CstIdentifier;
    }

    // Original Rule: ((LambdaParameter+WS)|('('+WS+(((LambdaParameter+WS+WS+((Comma+LambdaParameter+WS+WS))*)+(Comma)?))?+')'+WS))
    // Only Nodes: (LambdaParameter|((LambdaParameter+(LambdaParameter)*))?)
    // Optimized only nodes: (LambdaParameter|(LambdaParameter)*)
    public class CstLambdaParameters : CstChoice
    {
        public CstLambdaParameters(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLambdaParameters(Children.Select(f).ToArray());
        public CstLambdaParameter LambdaParameter => Children[0] as CstLambdaParameter;
        public CstZeroOrMore<CstLambdaParameter> LambdaParameter_1 => Children[0] as CstZeroOrMore<CstLambdaParameter>;
    }

    // Original Rule: ((CompoundStatement+WS)|(Expression+WS))
    // Only Nodes: (CompoundStatement|Expression)
    // Optimized only nodes: (CompoundStatement|Expression)
    public class CstLambdaBody : CstChoice
    {
        public CstLambdaBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLambdaBody(Children.Select(f).ToArray());
        public CstCompoundStatement CompoundStatement => Children[0] as CstCompoundStatement;
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: (LambdaParameters+WS+"=>"+WS+_RECOVER_+LambdaBody+WS)
    // Only Nodes: (LambdaParameters+LambdaBody)
    // Optimized only nodes: (LambdaParameters+LambdaBody)
    public class CstLambdaExpr : CstSequence
    {
        public CstLambdaExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLambdaExpr(Children.Select(f).ToArray());
        public CstLambdaParameters LambdaParameters => Children[0] as CstLambdaParameters;
        public CstLambdaBody LambdaBody => Children[1] as CstLambdaBody;
    }

    // Original Rule: ('.'+WS+Identifier+WS)
    // Only Nodes: Identifier
    // Optimized only nodes: Identifier
    public class CstMemberAccess : CstNode
    {
        public CstMemberAccess(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstMemberAccess(Children.Select(f).ToArray());
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
    }

    // Original Rule: ("\x3F\x2E"+WS+Identifier+WS)
    // Only Nodes: Identifier
    // Optimized only nodes: Identifier
    public class CstConditionalMemberAccess : CstNode
    {
        public CstConditionalMemberAccess(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConditionalMemberAccess(Children.Select(f).ToArray());
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
    }

    // Original Rule: ("typeof"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+TypeExpr+WS+')'+WS)
    // Only Nodes: TypeExpr
    // Optimized only nodes: TypeExpr
    public class CstTypeOf : CstNode
    {
        public CstTypeOf(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeOf(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
    }

    // Original Rule: ("nameof"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+Expression+WS+')'+WS)
    // Only Nodes: Expression
    // Optimized only nodes: Expression
    public class CstNameOf : CstNode
    {
        public CstNameOf(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstNameOf(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: ("default"+!(IdentifierChar)+WS+_RECOVER_+(('('+WS+TypeExpr+WS+')'+WS))?)
    // Only Nodes: (TypeExpr)?
    // Optimized only nodes: (TypeExpr)?
    public class CstDefault : CstNode
    {
        public CstDefault(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstDefault(Children.Select(f).ToArray());
        public CstOptional<CstTypeExpr> TypeExpr => Children[0] as CstOptional<CstTypeExpr>;
    }

    // Original Rule: ((Identifier+WS+'='+WS+_RECOVER_+Expression+WS)|(Expression+WS))
    // Only Nodes: ((Identifier+Expression)|Expression)
    // Optimized only nodes: ((Identifier)?+Expression)
    public class CstInitializerClause : CstSequence
    {
        public CstInitializerClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInitializerClause(Children.Select(f).ToArray());
        public CstOptional<CstIdentifier> Identifier => Children[0] as CstOptional<CstIdentifier>;
        public CstExpression Expression => Children[1] as CstExpression;
    }

    // Original Rule: ('{'+WS+_RECOVER_+(((InitializerClause+WS+WS+((Comma+InitializerClause+WS+WS))*)+(Comma)?))?+'}'+WS)
    // Only Nodes: ((InitializerClause+(InitializerClause)*))?
    // Optimized only nodes: (InitializerClause)*
    public class CstInitializer : CstNode
    {
        public CstInitializer(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInitializer(Children.Select(f).ToArray());
        public CstZeroOrMore<CstInitializerClause> InitializerClause => Children[0] as CstZeroOrMore<CstInitializerClause>;
    }

    // Original Rule: ('['+WS+Expression+WS+']'+WS)
    // Only Nodes: Expression
    // Optimized only nodes: Expression
    public class CstArraySizeSpecifier : CstNode
    {
        public CstArraySizeSpecifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstArraySizeSpecifier(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: ("new"+!(IdentifierChar)+WS+_RECOVER_+((TypeExpr+WS))?+((FunctionArgs+WS))?+((ArraySizeSpecifier+WS))?+((Initializer+WS))?)
    // Only Nodes: ((TypeExpr)?+(FunctionArgs)?+(ArraySizeSpecifier)?+(Initializer)?)
    // Optimized only nodes: ((TypeExpr)?+(FunctionArgs)?+(ArraySizeSpecifier)?+(Initializer)?)
    public class CstNewOperation : CstSequence
    {
        public CstNewOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstNewOperation(Children.Select(f).ToArray());
        public CstOptional<CstTypeExpr> TypeExpr => Children[0] as CstOptional<CstTypeExpr>;
        public CstOptional<CstFunctionArgs> FunctionArgs => Children[1] as CstOptional<CstFunctionArgs>;
        public CstOptional<CstArraySizeSpecifier> ArraySizeSpecifier => Children[2] as CstOptional<CstArraySizeSpecifier>;
        public CstOptional<CstInitializer> Initializer => Children[3] as CstOptional<CstInitializer>;
    }

    // Original Rule: ("is"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((Identifier+WS))?)
    // Only Nodes: (TypeExpr+(Identifier)?)
    // Optimized only nodes: (TypeExpr+(Identifier)?)
    public class CstIsOperation : CstSequence
    {
        public CstIsOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstIsOperation(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstOptional<CstIdentifier> Identifier => Children[1] as CstOptional<CstIdentifier>;
    }

    // Original Rule: ("as"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((Identifier+WS))?)
    // Only Nodes: (TypeExpr+(Identifier)?)
    // Optimized only nodes: (TypeExpr+(Identifier)?)
    public class CstAsOperation : CstSequence
    {
        public CstAsOperation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstAsOperation(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstOptional<CstIdentifier> Identifier => Children[1] as CstOptional<CstIdentifier>;
    }

    // Original Rule: (('{'+WS+_RECOVER_+Expression+WS+'}'+WS)|StringLiteralChar)
    // Only Nodes: Expression
    // Optimized only nodes: Expression
    public class CstStringInterpolationContent : CstNode
    {
        public CstStringInterpolationContent(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStringInterpolationContent(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: ('$'+_RECOVER_+'"'+((StringInterpolationContent+WS))*+'"')
    // Only Nodes: (StringInterpolationContent)*
    // Optimized only nodes: (StringInterpolationContent)*
    public class CstStringInterpolation : CstNode
    {
        public CstStringInterpolation(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStringInterpolation(Children.Select(f).ToArray());
        public CstZeroOrMore<CstStringInterpolationContent> StringInterpolationContent => Children[0] as CstZeroOrMore<CstStringInterpolationContent>;
    }

    // Original Rule: (("params"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS)|("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstFunctionArgKeyword : CstLeaf
    {
        public CstFunctionArgKeyword(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionArgKeyword(Text);
        // No children
    }

    // Original Rule: (((FunctionArgKeyword+WS))*+Expression+WS)
    // Only Nodes: ((FunctionArgKeyword)*+Expression)
    // Optimized only nodes: ((FunctionArgKeyword)*+Expression)
    public class CstFunctionArg : CstSequence
    {
        public CstFunctionArg(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionArg(Children.Select(f).ToArray());
        public CstZeroOrMore<CstFunctionArgKeyword> FunctionArgKeyword => Children[0] as CstZeroOrMore<CstFunctionArgKeyword>;
        public CstExpression Expression => Children[1] as CstExpression;
    }

    // Original Rule: ('('+WS+(((FunctionArg+WS+WS+((Comma+FunctionArg+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: ((FunctionArg+(FunctionArg)*))?
    // Optimized only nodes: (FunctionArg)*
    public class CstFunctionArgs : CstNode
    {
        public CstFunctionArgs(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionArgs(Children.Select(f).ToArray());
        public CstZeroOrMore<CstFunctionArg> FunctionArg => Children[0] as CstZeroOrMore<CstFunctionArg>;
    }

    // Original Rule: ((LambdaExpr+WS)|(CastExpression+WS)|(ParenthesizedExpression+WS)|(ThrowExpression+WS)|(Literal+WS)|(TypeOf+WS)|(NameOf+WS)|(Default+WS)|(NewOperation+WS)|(StringInterpolation+WS)|(Identifier+WS))
    // Only Nodes: (LambdaExpr|CastExpression|ParenthesizedExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)
    // Optimized only nodes: (LambdaExpr|CastExpression|ParenthesizedExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)
    public class CstLeafExpression : CstChoice
    {
        public CstLeafExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstLeafExpression(Children.Select(f).ToArray());
        public CstLambdaExpr LambdaExpr => Children[0] as CstLambdaExpr;
        public CstCastExpression CastExpression => Children[0] as CstCastExpression;
        public CstParenthesizedExpression ParenthesizedExpression => Children[0] as CstParenthesizedExpression;
        public CstThrowExpression ThrowExpression => Children[0] as CstThrowExpression;
        public CstLiteral Literal => Children[0] as CstLiteral;
        public CstTypeOf TypeOf => Children[0] as CstTypeOf;
        public CstNameOf NameOf => Children[0] as CstNameOf;
        public CstDefault Default => Children[0] as CstDefault;
        public CstNewOperation NewOperation => Children[0] as CstNewOperation;
        public CstStringInterpolation StringInterpolation => Children[0] as CstStringInterpolation;
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
    }

    // Original Rule: (((UnaryOperator+WS))*+LeafExpression+WS+((PostfixOperator+WS))*)
    // Only Nodes: ((UnaryOperator)*+LeafExpression+(PostfixOperator)*)
    // Optimized only nodes: ((UnaryOperator)*+LeafExpression+(PostfixOperator)*)
    public class CstExpression : CstSequence
    {
        public CstExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstExpression(Children.Select(f).ToArray());
        public CstZeroOrMore<CstUnaryOperator> UnaryOperator => Children[0] as CstZeroOrMore<CstUnaryOperator>;
        public CstLeafExpression LeafExpression => Children[1] as CstLeafExpression;
        public CstZeroOrMore<CstPostfixOperator> PostfixOperator => Children[2] as CstZeroOrMore<CstPostfixOperator>;
    }

    // Original Rule: (Expression+WS+_RECOVER_+EOS)
    // Only Nodes: Expression
    // Optimized only nodes: Expression
    public class CstExpressionStatement : CstNode
    {
        public CstExpressionStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstExpressionStatement(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: ("else"+!(IdentifierChar)+WS+_RECOVER_+Statement+WS)
    // Only Nodes: Statement
    // Optimized only nodes: Statement
    public class CstElseClause : CstNode
    {
        public CstElseClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstElseClause(Children.Select(f).ToArray());
        public CstStatement Statement => Children[0] as CstStatement;
    }

    // Original Rule: ("if"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS+Statement+WS+((ElseClause+WS))?)
    // Only Nodes: (ParenthesizedExpression+Statement+(ElseClause)?)
    // Optimized only nodes: (ParenthesizedExpression+Statement+(ElseClause)?)
    public class CstIfStatement : CstSequence
    {
        public CstIfStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstIfStatement(Children.Select(f).ToArray());
        public CstParenthesizedExpression ParenthesizedExpression => Children[0] as CstParenthesizedExpression;
        public CstStatement Statement => Children[1] as CstStatement;
        public CstOptional<CstElseClause> ElseClause => Children[2] as CstOptional<CstElseClause>;
    }

    // Original Rule: ("while"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS+Statement+WS)
    // Only Nodes: (ParenthesizedExpression+Statement)
    // Optimized only nodes: (ParenthesizedExpression+Statement)
    public class CstWhileStatement : CstSequence
    {
        public CstWhileStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstWhileStatement(Children.Select(f).ToArray());
        public CstParenthesizedExpression ParenthesizedExpression => Children[0] as CstParenthesizedExpression;
        public CstStatement Statement => Children[1] as CstStatement;
    }

    // Original Rule: ("do"+!(IdentifierChar)+WS+_RECOVER_+Statement+WS+"while"+!(IdentifierChar)+WS+ParenthesizedExpression+WS+EOS)
    // Only Nodes: (Statement+ParenthesizedExpression)
    // Optimized only nodes: (Statement+ParenthesizedExpression)
    public class CstDoWhileStatement : CstSequence
    {
        public CstDoWhileStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstDoWhileStatement(Children.Select(f).ToArray());
        public CstStatement Statement => Children[0] as CstStatement;
        public CstParenthesizedExpression ParenthesizedExpression => Children[1] as CstParenthesizedExpression;
    }

    // Original Rule: ("return"+!(IdentifierChar)+WS+_RECOVER_+((Expression+WS))?+EOS)
    // Only Nodes: (Expression)?
    // Optimized only nodes: (Expression)?
    public class CstReturnStatement : CstNode
    {
        public CstReturnStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstReturnStatement(Children.Select(f).ToArray());
        public CstOptional<CstExpression> Expression => Children[0] as CstOptional<CstExpression>;
    }

    // Original Rule: ("break"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstBreakStatement : CstLeaf
    {
        public CstBreakStatement(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBreakStatement(Text);
        // No children
    }

    // Original Rule: ("yield"+!(IdentifierChar)+WS+_RECOVER_+((YieldReturn+WS)|(YieldBreak+WS)))
    // Only Nodes: (YieldReturn|YieldBreak)
    // Optimized only nodes: (YieldReturn|YieldBreak)
    public class CstYieldStatement : CstChoice
    {
        public CstYieldStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstYieldStatement(Children.Select(f).ToArray());
        public CstYieldReturn YieldReturn => Children[0] as CstYieldReturn;
        public CstYieldBreak YieldBreak => Children[0] as CstYieldBreak;
    }

    // Original Rule: ("return"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS+EOS)
    // Only Nodes: Expression
    // Optimized only nodes: Expression
    public class CstYieldReturn : CstNode
    {
        public CstYieldReturn(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstYieldReturn(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: ("break"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstYieldBreak : CstLeaf
    {
        public CstYieldBreak(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstYieldBreak(Text);
        // No children
    }

    // Original Rule: ("continue"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstContinueStatement : CstLeaf
    {
        public CstContinueStatement(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstContinueStatement(Text);
        // No children
    }

    // Original Rule: ('{'+WS+_RECOVER_+((Statement+WS))*+'}'+WS)
    // Only Nodes: (Statement)*
    // Optimized only nodes: (Statement)*
    public class CstCompoundStatement : CstNode
    {
        public CstCompoundStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstCompoundStatement(Children.Select(f).ToArray());
        public CstZeroOrMore<CstStatement> Statement => Children[0] as CstZeroOrMore<CstStatement>;
    }

    // Original Rule: ("catch"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+VarDecl+WS+')'+WS+CompoundStatement+WS)
    // Only Nodes: (VarDecl+CompoundStatement)
    // Optimized only nodes: (VarDecl+CompoundStatement)
    public class CstCatchClause : CstSequence
    {
        public CstCatchClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstCatchClause(Children.Select(f).ToArray());
        public CstVarDecl VarDecl => Children[0] as CstVarDecl;
        public CstCompoundStatement CompoundStatement => Children[1] as CstCompoundStatement;
    }

    // Original Rule: ("finally"+!(IdentifierChar)+WS+CompoundStatement+WS)
    // Only Nodes: CompoundStatement
    // Optimized only nodes: CompoundStatement
    public class CstFinallyClause : CstNode
    {
        public CstFinallyClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFinallyClause(Children.Select(f).ToArray());
        public CstCompoundStatement CompoundStatement => Children[0] as CstCompoundStatement;
    }

    // Original Rule: ((("default"+!(IdentifierChar)+WS)|("case"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS))+(Statement+WS))
    // Only Nodes: (Expression+Statement)
    // Optimized only nodes: (Expression+Statement)
    public class CstCaseClause : CstSequence
    {
        public CstCaseClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstCaseClause(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
        public CstStatement Statement => Children[1] as CstStatement;
    }

    // Original Rule: ("switch"+!(IdentifierChar)+WS+_RECOVER_+'{'+WS+_RECOVER_+((CaseClause+WS))*+'}'+WS)
    // Only Nodes: (CaseClause)*
    // Optimized only nodes: (CaseClause)*
    public class CstSwitchStatement : CstNode
    {
        public CstSwitchStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstSwitchStatement(Children.Select(f).ToArray());
        public CstZeroOrMore<CstCaseClause> CaseClause => Children[0] as CstZeroOrMore<CstCaseClause>;
    }

    // Original Rule: ("try"+!(IdentifierChar)+WS+_RECOVER_+CompoundStatement+WS+((CatchClause+WS))?+((FinallyClause+WS))?)
    // Only Nodes: (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    // Optimized only nodes: (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    public class CstTryStatement : CstSequence
    {
        public CstTryStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTryStatement(Children.Select(f).ToArray());
        public CstCompoundStatement CompoundStatement => Children[0] as CstCompoundStatement;
        public CstOptional<CstCatchClause> CatchClause => Children[1] as CstOptional<CstCatchClause>;
        public CstOptional<CstFinallyClause> FinallyClause => Children[2] as CstOptional<CstFinallyClause>;
    }

    // Original Rule: ("foreach"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+VarDecl+WS+"in"+!(IdentifierChar)+WS+Expression+WS+')'+WS+Statement+WS)
    // Only Nodes: (VarDecl+Expression+Statement)
    // Optimized only nodes: (VarDecl+Expression+Statement)
    public class CstForEachStatement : CstSequence
    {
        public CstForEachStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstForEachStatement(Children.Select(f).ToArray());
        public CstVarDecl VarDecl => Children[0] as CstVarDecl;
        public CstExpression Expression => Children[1] as CstExpression;
        public CstStatement Statement => Children[2] as CstStatement;
    }

    // Original Rule: ((("static"+!(IdentifierChar)+WS))?+MethodDeclaration+WS)
    // Only Nodes: MethodDeclaration
    // Optimized only nodes: MethodDeclaration
    public class CstFunctionDeclStatement : CstNode
    {
        public CstFunctionDeclStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionDeclStatement(Children.Select(f).ToArray());
        public CstMethodDeclaration MethodDeclaration => Children[0] as CstMethodDeclaration;
    }

    // Original Rule: ((VarDecl+WS+Initialization+WS))?
    // Only Nodes: ((VarDecl+Initialization))?
    // Optimized only nodes: ((VarDecl+Initialization))?
    public class CstInitializationClause : CstNode
    {
        public CstInitializationClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInitializationClause(Children.Select(f).ToArray());
        public CstOptional<CstNode> Sequence => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: ((Expression+WS))?
    // Only Nodes: (Expression)?
    // Optimized only nodes: (Expression)?
    public class CstInvariantClause : CstNode
    {
        public CstInvariantClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInvariantClause(Children.Select(f).ToArray());
        public CstOptional<CstExpression> Expression => Children[0] as CstOptional<CstExpression>;
    }

    // Original Rule: ((Expression+WS))?
    // Only Nodes: (Expression)?
    // Optimized only nodes: (Expression)?
    public class CstVariantClause : CstNode
    {
        public CstVariantClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstVariantClause(Children.Select(f).ToArray());
        public CstOptional<CstExpression> Expression => Children[0] as CstOptional<CstExpression>;
    }

    // Original Rule: ("for"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+InitializationClause+WS+EOS+InvariantClause+WS+EOS+VariantClause+WS+')'+WS+Statement+WS)
    // Only Nodes: (InitializationClause+InvariantClause+VariantClause+Statement)
    // Optimized only nodes: (InitializationClause+InvariantClause+VariantClause+Statement)
    public class CstForStatement : CstSequence
    {
        public CstForStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstForStatement(Children.Select(f).ToArray());
        public CstInitializationClause InitializationClause => Children[0] as CstInitializationClause;
        public CstInvariantClause InvariantClause => Children[1] as CstInvariantClause;
        public CstVariantClause VariantClause => Children[2] as CstVariantClause;
        public CstStatement Statement => Children[3] as CstStatement;
    }

    // Original Rule: ('{'+WS+_RECOVER_+(((Expression+WS+WS+((Comma+Expression+WS+WS))*)+(Comma)?))?+'}'+WS)
    // Only Nodes: ((Expression+(Expression)*))?
    // Optimized only nodes: (Expression)*
    public class CstArrayInitializationValue : CstNode
    {
        public CstArrayInitializationValue(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstArrayInitializationValue(Children.Select(f).ToArray());
        public CstZeroOrMore<CstExpression> Expression => Children[0] as CstZeroOrMore<CstExpression>;
    }

    // Original Rule: ((ArrayInitializationValue+WS)|(Expression+WS))
    // Only Nodes: (ArrayInitializationValue|Expression)
    // Optimized only nodes: (ArrayInitializationValue|Expression)
    public class CstInitializationValue : CstChoice
    {
        public CstInitializationValue(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInitializationValue(Children.Select(f).ToArray());
        public CstArrayInitializationValue ArrayInitializationValue => Children[0] as CstArrayInitializationValue;
        public CstExpression Expression => Children[0] as CstExpression;
    }

    // Original Rule: (('='+WS+_RECOVER_+InitializationValue+WS))?
    // Only Nodes: (InitializationValue)?
    // Optimized only nodes: (InitializationValue)?
    public class CstInitialization : CstNode
    {
        public CstInitialization(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInitialization(Children.Select(f).ToArray());
        public CstOptional<CstInitializationValue> InitializationValue => Children[0] as CstOptional<CstInitializationValue>;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS)
    // Only Nodes: (TypeExpr+Identifier)
    // Optimized only nodes: (TypeExpr+Identifier)
    public class CstVarDecl : CstSequence
    {
        public CstVarDecl(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstVarDecl(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstIdentifier Identifier => Children[1] as CstIdentifier;
    }

    // Original Rule: (VarDecl+WS+Initialization+WS+EOS)
    // Only Nodes: (VarDecl+Initialization)
    // Optimized only nodes: (VarDecl+Initialization)
    public class CstVarDeclStatement : CstSequence
    {
        public CstVarDeclStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstVarDeclStatement(Children.Select(f).ToArray());
        public CstVarDecl VarDecl => Children[0] as CstVarDecl;
        public CstInitialization Initialization => Children[1] as CstInitialization;
    }

    // Original Rule: (EOS|(CompoundStatement+WS)|(IfStatement+WS)|(WhileStatement+WS)|(DoWhileStatement+WS)|(ReturnStatement+WS)|(BreakStatement+WS)|(ContinueStatement+WS)|(ForStatement+WS)|(ForEachStatement+WS)|(FunctionDeclStatement+WS)|(VarDeclStatement+WS)|(TryStatement+WS)|(YieldStatement+WS)|(SwitchStatement+WS)|(ExpressionStatement+WS))
    // Only Nodes: (CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|FunctionDeclStatement|VarDeclStatement|TryStatement|YieldStatement|SwitchStatement|ExpressionStatement)
    // Optimized only nodes: (CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|FunctionDeclStatement|VarDeclStatement|TryStatement|YieldStatement|SwitchStatement|ExpressionStatement)
    public class CstStatement : CstChoice
    {
        public CstStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStatement(Children.Select(f).ToArray());
        public CstCompoundStatement CompoundStatement => Children[0] as CstCompoundStatement;
        public CstIfStatement IfStatement => Children[0] as CstIfStatement;
        public CstWhileStatement WhileStatement => Children[0] as CstWhileStatement;
        public CstDoWhileStatement DoWhileStatement => Children[0] as CstDoWhileStatement;
        public CstReturnStatement ReturnStatement => Children[0] as CstReturnStatement;
        public CstBreakStatement BreakStatement => Children[0] as CstBreakStatement;
        public CstContinueStatement ContinueStatement => Children[0] as CstContinueStatement;
        public CstForStatement ForStatement => Children[0] as CstForStatement;
        public CstForEachStatement ForEachStatement => Children[0] as CstForEachStatement;
        public CstFunctionDeclStatement FunctionDeclStatement => Children[0] as CstFunctionDeclStatement;
        public CstVarDeclStatement VarDeclStatement => Children[0] as CstVarDeclStatement;
        public CstTryStatement TryStatement => Children[0] as CstTryStatement;
        public CstYieldStatement YieldStatement => Children[0] as CstYieldStatement;
        public CstSwitchStatement SwitchStatement => Children[0] as CstSwitchStatement;
        public CstExpressionStatement ExpressionStatement => Children[0] as CstExpressionStatement;
    }

    // Original Rule: (((Identifier+WS+WS+(('.'+WS+Identifier+WS+WS))*)+(('.'+WS))?))?
    // Only Nodes: ((Identifier+(Identifier)*))?
    // Optimized only nodes: (Identifier)*
    public class CstQualifiedIdentifier : CstNode
    {
        public CstQualifiedIdentifier(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstQualifiedIdentifier(Children.Select(f).ToArray());
        public CstZeroOrMore<CstIdentifier> Identifier => Children[0] as CstZeroOrMore<CstIdentifier>;
    }

    // Original Rule: (("static"+!(IdentifierChar)+WS))?
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstStatic : CstLeaf
    {
        public CstStatic(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStatic(Text);
        // No children
    }

    // Original Rule: ((("global"+!(IdentifierChar)+WS))?+"using"+!(IdentifierChar)+WS+_RECOVER_+Static+WS+QualifiedIdentifier+WS+(('='+WS+QualifiedIdentifier+WS))?+EOS)
    // Only Nodes: (Static+QualifiedIdentifier+(QualifiedIdentifier)?)
    // Optimized only nodes: (Static+QualifiedIdentifier+(QualifiedIdentifier)?)
    public class CstUsingDirective : CstSequence
    {
        public CstUsingDirective(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstUsingDirective(Children.Select(f).ToArray());
        public CstStatic Static => Children[0] as CstStatic;
        public CstQualifiedIdentifier QualifiedIdentifier => Children[1] as CstQualifiedIdentifier;
        public CstOptional<CstQualifiedIdentifier> QualifiedIdentifier_1 => Children[2] as CstOptional<CstQualifiedIdentifier>;
    }

    // Original Rule: (("readonly"+!(IdentifierChar)+WS)|("abstract"+!(IdentifierChar)+WS)|("partial"+!(IdentifierChar)+WS)|("virtual"+!(IdentifierChar)+WS)|("static"+!(IdentifierChar)+WS)|("sealed"+!(IdentifierChar)+WS)|("const"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstModifier : CstLeaf
    {
        public CstModifier(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstModifier(Text);
        // No children
    }

    // Original Rule: (("protected"+!(IdentifierChar)+WS)|("internal"+!(IdentifierChar)+WS)|("private"+!(IdentifierChar)+WS)|("public"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstAccessSpecifier : CstLeaf
    {
        public CstAccessSpecifier(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstAccessSpecifier(Text);
        // No children
    }

    // Original Rule: (Identifier+WS+((FunctionArgs+WS))?)
    // Only Nodes: (Identifier+(FunctionArgs)?)
    // Optimized only nodes: (Identifier+(FunctionArgs)?)
    public class CstAttribute : CstSequence
    {
        public CstAttribute(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstAttribute(Children.Select(f).ToArray());
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
        public CstOptional<CstFunctionArgs> FunctionArgs => Children[1] as CstOptional<CstFunctionArgs>;
    }

    // Original Rule: ('['+WS+(((Attribute+WS+WS+((Comma+Attribute+WS+WS))*)+(Comma)?))?+']'+WS)
    // Only Nodes: ((Attribute+(Attribute)*))?
    // Optimized only nodes: (Attribute)*
    public class CstAttributeGroup : CstNode
    {
        public CstAttributeGroup(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstAttributeGroup(Children.Select(f).ToArray());
        public CstZeroOrMore<CstAttribute> Attribute => Children[0] as CstZeroOrMore<CstAttribute>;
    }

    // Original Rule: ((AttributeGroup+WS))*
    // Only Nodes: (AttributeGroup)*
    // Optimized only nodes: (AttributeGroup)*
    public class CstAttributeList : CstNode
    {
        public CstAttributeList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstAttributeList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstAttributeGroup> AttributeGroup => Children[0] as CstZeroOrMore<CstAttributeGroup>;
    }

    // Original Rule: (AttributeList+WS+(((Modifier+WS)|(AccessSpecifier+WS)))*)
    // Only Nodes: (AttributeList+((Modifier|AccessSpecifier))*)
    // Optimized only nodes: (AttributeList+((Modifier|AccessSpecifier))*)
    public class CstDeclarationPreamble : CstSequence
    {
        public CstDeclarationPreamble(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstDeclarationPreamble(Children.Select(f).ToArray());
        public CstAttributeList AttributeList => Children[0] as CstAttributeList;
        public CstZeroOrMore<CstNode> Choices => Children[1] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: ((("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS)))?
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstTypeVariance : CstLeaf
    {
        public CstTypeVariance(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeVariance(Text);
        // No children
    }

    // Original Rule: (TypeVariance+WS+Identifier+WS)
    // Only Nodes: (TypeVariance+Identifier)
    // Optimized only nodes: (TypeVariance+Identifier)
    public class CstTypeParameter : CstSequence
    {
        public CstTypeParameter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeParameter(Children.Select(f).ToArray());
        public CstTypeVariance TypeVariance => Children[0] as CstTypeVariance;
        public CstIdentifier Identifier => Children[1] as CstIdentifier;
    }

    // Original Rule: (('<'+WS+(((TypeParameter+WS+WS+((Comma+TypeParameter+WS+WS))*)+(Comma)?))?+'>'+WS))?
    // Only Nodes: (((TypeParameter+(TypeParameter)*))?)?
    // Optimized only nodes: (TypeParameter)*
    public class CstTypeParameterList : CstNode
    {
        public CstTypeParameterList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeParameterList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstTypeParameter> TypeParameter => Children[0] as CstZeroOrMore<CstTypeParameter>;
    }

    // Original Rule: ((':'+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?))?
    // Only Nodes: (((TypeExpr+(TypeExpr)*))?)?
    // Optimized only nodes: (TypeExpr)*
    public class CstBaseClassList : CstNode
    {
        public CstBaseClassList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBaseClassList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstTypeExpr> TypeExpr => Children[0] as CstZeroOrMore<CstTypeExpr>;
    }

    // Original Rule: (("class"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|(TypeExpr+WS))
    // Only Nodes: TypeExpr
    // Optimized only nodes: TypeExpr
    public class CstConstraint : CstNode
    {
        public CstConstraint(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConstraint(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
    }

    // Original Rule: ("where"+!(IdentifierChar)+WS+Identifier+WS+':'+WS+TypeExpr+WS)
    // Only Nodes: (Identifier+TypeExpr)
    // Optimized only nodes: (Identifier+TypeExpr)
    public class CstConstraintClause : CstSequence
    {
        public CstConstraintClause(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConstraintClause(Children.Select(f).ToArray());
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
        public CstTypeExpr TypeExpr => Children[1] as CstTypeExpr;
    }

    // Original Rule: ((ConstraintClause+WS))*
    // Only Nodes: (ConstraintClause)*
    // Optimized only nodes: (ConstraintClause)*
    public class CstConstraintList : CstNode
    {
        public CstConstraintList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConstraintList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstConstraintClause> ConstraintClause => Children[0] as CstZeroOrMore<CstConstraintClause>;
    }

    // Original Rule: (("interface"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|("class"+!(IdentifierChar)+WS)|("enum"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstKind : CstLeaf
    {
        public CstKind(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstKind(Text);
        // No children
    }

    // Original Rule: (Kind+WS+_RECOVER_+Identifier+WS+TypeParameterList+WS+BaseClassList+WS+ConstraintList+WS+'{'+WS+_RECOVER_+((MemberDeclaration+WS))*+'}'+WS)
    // Only Nodes: (Kind+Identifier+TypeParameterList+BaseClassList+ConstraintList+(MemberDeclaration)*)
    // Optimized only nodes: (Kind+Identifier+TypeParameterList+BaseClassList+ConstraintList+(MemberDeclaration)*)
    public class CstTypeDeclaration : CstSequence
    {
        public CstTypeDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeDeclaration(Children.Select(f).ToArray());
        public CstKind Kind => Children[0] as CstKind;
        public CstIdentifier Identifier => Children[1] as CstIdentifier;
        public CstTypeParameterList TypeParameterList => Children[2] as CstTypeParameterList;
        public CstBaseClassList BaseClassList => Children[3] as CstBaseClassList;
        public CstConstraintList ConstraintList => Children[4] as CstConstraintList;
        public CstZeroOrMore<CstMemberDeclaration> MemberDeclaration => Children[5] as CstZeroOrMore<CstMemberDeclaration>;
    }

    // Original Rule: (DeclarationPreamble+WS+TypeDeclaration+WS)
    // Only Nodes: (DeclarationPreamble+TypeDeclaration)
    // Optimized only nodes: (DeclarationPreamble+TypeDeclaration)
    public class CstTypeDeclarationWithPreamble : CstSequence
    {
        public CstTypeDeclarationWithPreamble(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeDeclarationWithPreamble(Children.Select(f).ToArray());
        public CstDeclarationPreamble DeclarationPreamble => Children[0] as CstDeclarationPreamble;
        public CstTypeDeclaration TypeDeclaration => Children[1] as CstTypeDeclaration;
    }

    // Original Rule: ((("params"+!(IdentifierChar)+WS)|("this"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS)|("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS)))?
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstFunctionParameterKeywords : CstLeaf
    {
        public CstFunctionParameterKeywords(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionParameterKeywords(Text);
        // No children
    }

    // Original Rule: (('='+WS+Expression+WS))?
    // Only Nodes: (Expression)?
    // Optimized only nodes: (Expression)?
    public class CstDefaultValue : CstNode
    {
        public CstDefaultValue(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstDefaultValue(Children.Select(f).ToArray());
        public CstOptional<CstExpression> Expression => Children[0] as CstOptional<CstExpression>;
    }

    // Original Rule: (AttributeList+WS+FunctionParameterKeywords+WS+TypeExpr+WS+Identifier+WS+DefaultValue+WS)
    // Only Nodes: (AttributeList+FunctionParameterKeywords+TypeExpr+Identifier+DefaultValue)
    // Optimized only nodes: (AttributeList+FunctionParameterKeywords+TypeExpr+Identifier+DefaultValue)
    public class CstFunctionParameter : CstSequence
    {
        public CstFunctionParameter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionParameter(Children.Select(f).ToArray());
        public CstAttributeList AttributeList => Children[0] as CstAttributeList;
        public CstFunctionParameterKeywords FunctionParameterKeywords => Children[1] as CstFunctionParameterKeywords;
        public CstTypeExpr TypeExpr => Children[2] as CstTypeExpr;
        public CstIdentifier Identifier => Children[3] as CstIdentifier;
        public CstDefaultValue DefaultValue => Children[4] as CstDefaultValue;
    }

    // Original Rule: ('('+WS+(((FunctionParameter+WS+WS+((Comma+FunctionParameter+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: ((FunctionParameter+(FunctionParameter)*))?
    // Optimized only nodes: (FunctionParameter)*
    public class CstFunctionParameterList : CstNode
    {
        public CstFunctionParameterList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionParameterList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstFunctionParameter> FunctionParameter => Children[0] as CstZeroOrMore<CstFunctionParameter>;
    }

    // Original Rule: ("=>"+WS+_RECOVER_+((Expression+WS+EOS)|(CompoundStatement+WS)))
    // Only Nodes: (Expression|CompoundStatement)
    // Optimized only nodes: (Expression|CompoundStatement)
    public class CstExpressionBody : CstChoice
    {
        public CstExpressionBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstExpressionBody(Children.Select(f).ToArray());
        public CstExpression Expression => Children[0] as CstExpression;
        public CstCompoundStatement CompoundStatement => Children[0] as CstCompoundStatement;
    }

    // Original Rule: ((ExpressionBody+WS)|(CompoundStatement+WS)|EOS)
    // Only Nodes: (ExpressionBody|CompoundStatement)
    // Optimized only nodes: (ExpressionBody|CompoundStatement)
    public class CstFunctionBody : CstChoice
    {
        public CstFunctionBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFunctionBody(Children.Select(f).ToArray());
        public CstExpressionBody ExpressionBody => Children[0] as CstExpressionBody;
        public CstCompoundStatement CompoundStatement => Children[0] as CstCompoundStatement;
    }

    // Original Rule: ("base"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS)
    // Only Nodes: ParenthesizedExpression
    // Optimized only nodes: ParenthesizedExpression
    public class CstBaseCall : CstNode
    {
        public CstBaseCall(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBaseCall(Children.Select(f).ToArray());
        public CstParenthesizedExpression ParenthesizedExpression => Children[0] as CstParenthesizedExpression;
    }

    // Original Rule: ("this"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS)
    // Only Nodes: ParenthesizedExpression
    // Optimized only nodes: ParenthesizedExpression
    public class CstThisCall : CstNode
    {
        public CstThisCall(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstThisCall(Children.Select(f).ToArray());
        public CstParenthesizedExpression ParenthesizedExpression => Children[0] as CstParenthesizedExpression;
    }

    // Original Rule: ((':'+WS+((BaseCall+WS)|(ThisCall+WS))))?
    // Only Nodes: ((BaseCall|ThisCall))?
    // Optimized only nodes: ((BaseCall|ThisCall))?
    public class CstBaseOrThisCall : CstNode
    {
        public CstBaseOrThisCall(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBaseOrThisCall(Children.Select(f).ToArray());
        public CstOptional<CstNode> Choices => Children[0] as CstOptional<CstNode>;
    }

    // Original Rule: (Identifier+WS+FunctionParameterList+WS+_RECOVER_+BaseOrThisCall+WS+FunctionBody+WS)
    // Only Nodes: (Identifier+FunctionParameterList+BaseOrThisCall+FunctionBody)
    // Optimized only nodes: (Identifier+FunctionParameterList+BaseOrThisCall+FunctionBody)
    public class CstConstructorDeclaration : CstSequence
    {
        public CstConstructorDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConstructorDeclaration(Children.Select(f).ToArray());
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
        public CstFunctionParameterList FunctionParameterList => Children[1] as CstFunctionParameterList;
        public CstBaseOrThisCall BaseOrThisCall => Children[2] as CstBaseOrThisCall;
        public CstFunctionBody FunctionBody => Children[3] as CstFunctionBody;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+FunctionParameterList+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (TypeExpr+Identifier+FunctionParameterList+FunctionBody)
    // Optimized only nodes: (TypeExpr+Identifier+FunctionParameterList+FunctionBody)
    public class CstMethodDeclaration : CstSequence
    {
        public CstMethodDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstMethodDeclaration(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstIdentifier Identifier => Children[1] as CstIdentifier;
        public CstFunctionParameterList FunctionParameterList => Children[2] as CstFunctionParameterList;
        public CstFunctionBody FunctionBody => Children[3] as CstFunctionBody;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+((Initialization+WS))?+EOS)
    // Only Nodes: (TypeExpr+Identifier+(Initialization)?)
    // Optimized only nodes: (TypeExpr+Identifier+(Initialization)?)
    public class CstFieldDeclaration : CstSequence
    {
        public CstFieldDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFieldDeclaration(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstIdentifier Identifier => Children[1] as CstIdentifier;
        public CstOptional<CstInitialization> Initialization => Children[2] as CstOptional<CstInitialization>;
    }

    // Original Rule: ("get"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: FunctionBody
    // Optimized only nodes: FunctionBody
    public class CstGetter : CstNode
    {
        public CstGetter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstGetter(Children.Select(f).ToArray());
        public CstFunctionBody FunctionBody => Children[0] as CstFunctionBody;
    }

    // Original Rule: ("set"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: FunctionBody
    // Optimized only nodes: FunctionBody
    public class CstSetter : CstNode
    {
        public CstSetter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstSetter(Children.Select(f).ToArray());
        public CstFunctionBody FunctionBody => Children[0] as CstFunctionBody;
    }

    // Original Rule: ("init"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: FunctionBody
    // Optimized only nodes: FunctionBody
    public class CstInitter : CstNode
    {
        public CstInitter(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInitter(Children.Select(f).ToArray());
        public CstFunctionBody FunctionBody => Children[0] as CstFunctionBody;
    }

    // Original Rule: (((Getter+WS)|(Setter+WS)|(Initter+WS)))+
    // Only Nodes: ((Getter|Setter|Initter))+
    // Optimized only nodes: ((Getter|Setter|Initter))+
    public class CstPropertyClauses : CstNode
    {
        public CstPropertyClauses(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstPropertyClauses(Children.Select(f).ToArray());
        public CstOneOrMore<CstNode> Choices => Children[0] as CstOneOrMore<CstNode>;
    }

    // Original Rule: ('{'+WS+_RECOVER_+PropertyClauses+WS+'}'+WS+((Initialization+WS+EOS))?)
    // Only Nodes: (PropertyClauses+(Initialization)?)
    // Optimized only nodes: (PropertyClauses+(Initialization)?)
    public class CstPropertyWithClauses : CstSequence
    {
        public CstPropertyWithClauses(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstPropertyWithClauses(Children.Select(f).ToArray());
        public CstPropertyClauses PropertyClauses => Children[0] as CstPropertyClauses;
        public CstOptional<CstInitialization> Initialization => Children[1] as CstOptional<CstInitialization>;
    }

    // Original Rule: (ExpressionBody+WS)
    // Only Nodes: ExpressionBody
    // Optimized only nodes: ExpressionBody
    public class CstPropertyExpression : CstNode
    {
        public CstPropertyExpression(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstPropertyExpression(Children.Select(f).ToArray());
        public CstExpressionBody ExpressionBody => Children[0] as CstExpressionBody;
    }

    // Original Rule: ((PropertyExpression+WS)|(PropertyWithClauses+WS))
    // Only Nodes: (PropertyExpression|PropertyWithClauses)
    // Optimized only nodes: (PropertyExpression|PropertyWithClauses)
    public class CstPropertyBody : CstChoice
    {
        public CstPropertyBody(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstPropertyBody(Children.Select(f).ToArray());
        public CstPropertyExpression PropertyExpression => Children[0] as CstPropertyExpression;
        public CstPropertyWithClauses PropertyWithClauses => Children[0] as CstPropertyWithClauses;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+PropertyBody+WS)
    // Only Nodes: (TypeExpr+Identifier+PropertyBody)
    // Optimized only nodes: (TypeExpr+Identifier+PropertyBody)
    public class CstPropertyDeclaration : CstSequence
    {
        public CstPropertyDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstPropertyDeclaration(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstIdentifier Identifier => Children[1] as CstIdentifier;
        public CstPropertyBody PropertyBody => Children[2] as CstPropertyBody;
    }

    // Original Rule: (TypeExpr+WS+"this"+!(IdentifierChar)+WS+_RECOVER_+'['+WS+FunctionParameter+WS+']'+WS+PropertyBody+WS)
    // Only Nodes: (TypeExpr+FunctionParameter+PropertyBody)
    // Optimized only nodes: (TypeExpr+FunctionParameter+PropertyBody)
    public class CstIndexerDeclaration : CstSequence
    {
        public CstIndexerDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstIndexerDeclaration(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstFunctionParameter FunctionParameter => Children[1] as CstFunctionParameter;
        public CstPropertyBody PropertyBody => Children[2] as CstPropertyBody;
    }

    // Original Rule: (TypeExpr+WS+"operator"+!(IdentifierChar)+WS+_RECOVER_+OverloadableOperator+WS+FunctionParameterList+WS+FunctionBody+WS)
    // Only Nodes: (TypeExpr+OverloadableOperator+FunctionParameterList+FunctionBody)
    // Optimized only nodes: (TypeExpr+OverloadableOperator+FunctionParameterList+FunctionBody)
    public class CstOperatorDeclaration : CstSequence
    {
        public CstOperatorDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstOperatorDeclaration(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstOverloadableOperator OverloadableOperator => Children[1] as CstOverloadableOperator;
        public CstFunctionParameterList FunctionParameterList => Children[2] as CstFunctionParameterList;
        public CstFunctionBody FunctionBody => Children[3] as CstFunctionBody;
    }

    // Original Rule: (("implicit"+!(IdentifierChar)+WS)|("explicit"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstImplicitOrExplicit : CstLeaf
    {
        public CstImplicitOrExplicit(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstImplicitOrExplicit(Text);
        // No children
    }

    // Original Rule: (TypeExpr+WS+ImplicitOrExplicit+WS+"operator"+!(IdentifierChar)+WS+TypeExpr+WS+FunctionBody+WS)
    // Only Nodes: (TypeExpr+ImplicitOrExplicit+TypeExpr+FunctionBody)
    // Optimized only nodes: (TypeExpr+ImplicitOrExplicit+TypeExpr+FunctionBody)
    public class CstConverterDeclaration : CstSequence
    {
        public CstConverterDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstConverterDeclaration(Children.Select(f).ToArray());
        public CstTypeExpr TypeExpr => Children[0] as CstTypeExpr;
        public CstImplicitOrExplicit ImplicitOrExplicit => Children[1] as CstImplicitOrExplicit;
        public CstTypeExpr TypeExpr_1 => Children[2] as CstTypeExpr;
        public CstFunctionBody FunctionBody => Children[3] as CstFunctionBody;
    }

    // Original Rule: (DeclarationPreamble+WS+((ConstructorDeclaration+WS)|(MethodDeclaration+WS)|(IndexerDeclaration+WS)|(PropertyDeclaration+WS)|(FieldDeclaration+WS)|(OperatorDeclaration+WS)|(ConverterDeclaration+WS)|(TypeDeclaration+WS)))
    // Only Nodes: (DeclarationPreamble+(ConstructorDeclaration|MethodDeclaration|IndexerDeclaration|PropertyDeclaration|FieldDeclaration|OperatorDeclaration|ConverterDeclaration|TypeDeclaration))
    // Optimized only nodes: (DeclarationPreamble+(ConstructorDeclaration|MethodDeclaration|IndexerDeclaration|PropertyDeclaration|FieldDeclaration|OperatorDeclaration|ConverterDeclaration|TypeDeclaration))
    public class CstMemberDeclaration : CstSequence
    {
        public CstMemberDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstMemberDeclaration(Children.Select(f).ToArray());
        public CstDeclarationPreamble DeclarationPreamble => Children[0] as CstDeclarationPreamble;
        public CstChoice Choices => Children[1] as CstChoice;
    }

    // Original Rule: ("namespace"+!(IdentifierChar)+WS+QualifiedIdentifier+WS+(ImplicitlyOrExplicitlyScopedTypes|('{'+WS+_RECOVER_+TypesAndDirectives+'}'+WS)))
    // Only Nodes: (QualifiedIdentifier+(((UsingDirective|TypeDeclarationWithPreamble))*|((UsingDirective|TypeDeclarationWithPreamble))*))
    // Optimized only nodes: (QualifiedIdentifier+((UsingDirective|TypeDeclarationWithPreamble))*)
    public class CstNamespaceDeclaration : CstSequence
    {
        public CstNamespaceDeclaration(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstNamespaceDeclaration(Children.Select(f).ToArray());
        public CstQualifiedIdentifier QualifiedIdentifier => Children[0] as CstQualifiedIdentifier;
        public CstZeroOrMore<CstNode> Choices => Children[1] as CstZeroOrMore<CstNode>;
    }

    // Original Rule: (WS+((UsingDirective+WS))*+((NamespaceDeclaration+WS))?)
    // Only Nodes: ((UsingDirective)*+(NamespaceDeclaration)?)
    // Optimized only nodes: ((UsingDirective)*+(NamespaceDeclaration)?)
    public class CstFile : CstSequence
    {
        public CstFile(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFile(Children.Select(f).ToArray());
        public CstZeroOrMore<CstUsingDirective> UsingDirective => Children[0] as CstZeroOrMore<CstUsingDirective>;
        public CstOptional<CstNamespaceDeclaration> NamespaceDeclaration => Children[1] as CstOptional<CstNamespaceDeclaration>;
    }

    // Original Rule: ('['+WS+(Comma)*+']'+WS)
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstArrayRankSpecifier : CstLeaf
    {
        public CstArrayRankSpecifier(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstArrayRankSpecifier(Text);
        // No children
    }

    // Original Rule: ((ArrayRankSpecifier+WS))*
    // Only Nodes: (ArrayRankSpecifier)*
    // Optimized only nodes: (ArrayRankSpecifier)*
    public class CstArrayRankSpecifiers : CstNode
    {
        public CstArrayRankSpecifiers(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstArrayRankSpecifiers(Children.Select(f).ToArray());
        public CstZeroOrMore<CstArrayRankSpecifier> ArrayRankSpecifier => Children[0] as CstZeroOrMore<CstArrayRankSpecifier>;
    }

    // Original Rule: ('<'+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?+'>'+WS)
    // Only Nodes: ((TypeExpr+(TypeExpr)*))?
    // Optimized only nodes: (TypeExpr)*
    public class CstTypeArgList : CstNode
    {
        public CstTypeArgList(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeArgList(Children.Select(f).ToArray());
        public CstZeroOrMore<CstTypeExpr> TypeExpr => Children[0] as CstZeroOrMore<CstTypeExpr>;
    }

    // Original Rule: (('?'+WS))?
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstNullable : CstLeaf
    {
        public CstNullable(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstNullable(Text);
        // No children
    }

    // Original Rule: ('('+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: ((TypeExpr+(TypeExpr)*))?
    // Optimized only nodes: (TypeExpr)*
    public class CstCompoundTypeExpr : CstNode
    {
        public CstCompoundTypeExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstCompoundTypeExpr(Children.Select(f).ToArray());
        public CstZeroOrMore<CstTypeExpr> TypeExpr => Children[0] as CstZeroOrMore<CstTypeExpr>;
    }

    // Original Rule: (((CompoundTypeExpr+WS)|SimpleTypExpr)+((TypeArgList+WS))?+ArrayRankSpecifiers+WS)
    // Only Nodes: ((CompoundTypeExpr|QualifiedIdentifier)+(TypeArgList)?+ArrayRankSpecifiers)
    // Optimized only nodes: ((CompoundTypeExpr|QualifiedIdentifier)+(TypeArgList)?+ArrayRankSpecifiers)
    public class CstInnerTypeExpr : CstSequence
    {
        public CstInnerTypeExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstInnerTypeExpr(Children.Select(f).ToArray());
        public CstChoice Choices => Children[0] as CstChoice;
        public CstOptional<CstTypeArgList> TypeArgList => Children[1] as CstOptional<CstTypeArgList>;
        public CstArrayRankSpecifiers ArrayRankSpecifiers => Children[2] as CstArrayRankSpecifiers;
    }

    // Original Rule: (InnerTypeExpr+WS)
    // Only Nodes: InnerTypeExpr
    // Optimized only nodes: InnerTypeExpr
    public class CstTypeExpr : CstNode
    {
        public CstTypeExpr(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeExpr(Children.Select(f).ToArray());
        public CstInnerTypeExpr InnerTypeExpr => Children[0] as CstInnerTypeExpr;
    }

    // Original Rule: ([\x2C\x2E\x3B]|(TypeKeyword+WS)|(StatementKeyword+WS))
    // Only Nodes: (TypeKeyword|StatementKeyword)
    // Optimized only nodes: (TypeKeyword|StatementKeyword)
    public class CstSeparator : CstChoice
    {
        public CstSeparator(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstSeparator(Children.Select(f).ToArray());
        public CstTypeKeyword TypeKeyword => Children[0] as CstTypeKeyword;
        public CstStatementKeyword StatementKeyword => Children[0] as CstStatementKeyword;
    }

    // Original Rule: (("interface"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|("class"+!(IdentifierChar)+WS)|("enum"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstTypeKeyword : CstLeaf
    {
        public CstTypeKeyword(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeKeyword(Text);
        // No children
    }

    // Original Rule: (("continue"+!(IdentifierChar)+WS)|("foreach"+!(IdentifierChar)+WS)|("finally"+!(IdentifierChar)+WS)|("default"+!(IdentifierChar)+WS)|("return"+!(IdentifierChar)+WS)|("switch"+!(IdentifierChar)+WS)|("break"+!(IdentifierChar)+WS)|("throw"+!(IdentifierChar)+WS)|("catch"+!(IdentifierChar)+WS)|("using"+!(IdentifierChar)+WS)|("case"+!(IdentifierChar)+WS)|("for"+!(IdentifierChar)+WS)|("try"+!(IdentifierChar)+WS)|("if"+!(IdentifierChar)+WS)|("do"+!(IdentifierChar)+WS))
    // Only Nodes: 
    // Optimized only nodes: 
    public class CstStatementKeyword : CstLeaf
    {
        public CstStatementKeyword(string text) : base(text) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStatementKeyword(Text);
        // No children
    }

    // Original Rule: ((Separator+WS)|CppStyleComment|Spaces|([\x21\x23-\x26\x2A+\x2D\x2F\x3A<-\x40^|~])+|(Identifier+WS)|(Literal+WS))
    // Only Nodes: (Separator|Identifier|Literal)
    // Optimized only nodes: (Separator|Identifier|Literal)
    public class CstToken : CstChoice
    {
        public CstToken(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstToken(Children.Select(f).ToArray());
        public CstSeparator Separator => Children[0] as CstSeparator;
        public CstIdentifier Identifier => Children[0] as CstIdentifier;
        public CstLiteral Literal => Children[0] as CstLiteral;
    }

    // Original Rule: ((!([\x28\x29\x5B\x5D\x7B\x7D])+((Token+WS)|(Separator+WS))))+
    // Only Nodes: ((Token|Separator))+
    // Optimized only nodes: ((Token|Separator))+
    public class CstTokenGroup : CstNode
    {
        public CstTokenGroup(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTokenGroup(Children.Select(f).ToArray());
        public CstOneOrMore<CstNode> Choices => Children[0] as CstOneOrMore<CstNode>;
    }

    // Original Rule: (TypeKeyword+WS+TokenGroup+WS+BracedStructure+WS)
    // Only Nodes: (TypeKeyword+TokenGroup+BracedStructure)
    // Optimized only nodes: (TypeKeyword+TokenGroup+BracedStructure)
    public class CstTypeStructure : CstSequence
    {
        public CstTypeStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeStructure(Children.Select(f).ToArray());
        public CstTypeKeyword TypeKeyword => Children[0] as CstTypeKeyword;
        public CstTokenGroup TokenGroup => Children[1] as CstTokenGroup;
        public CstBracedStructure BracedStructure => Children[2] as CstBracedStructure;
    }

    // Original Rule: (StatementKeyword+WS+TokenGroup+WS+((BracedStructure+WS))?)
    // Only Nodes: (StatementKeyword+TokenGroup+(BracedStructure)?)
    // Optimized only nodes: (StatementKeyword+TokenGroup+(BracedStructure)?)
    public class CstStatementStructure : CstSequence
    {
        public CstStatementStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStatementStructure(Children.Select(f).ToArray());
        public CstStatementKeyword StatementKeyword => Children[0] as CstStatementKeyword;
        public CstTokenGroup TokenGroup => Children[1] as CstTokenGroup;
        public CstOptional<CstBracedStructure> BracedStructure => Children[2] as CstOptional<CstBracedStructure>;
    }

    // Original Rule: ((Structure+WS)|(TokenGroup+WS))
    // Only Nodes: (Structure|TokenGroup)
    // Optimized only nodes: (Structure|TokenGroup)
    public class CstElement : CstChoice
    {
        public CstElement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstElement(Children.Select(f).ToArray());
        public CstStructure Structure => Children[0] as CstStructure;
        public CstTokenGroup TokenGroup => Children[0] as CstTokenGroup;
    }

    // Original Rule: ('{'+((Element+WS))*+'}')
    // Only Nodes: (Element)*
    // Optimized only nodes: (Element)*
    public class CstBracedStructure : CstNode
    {
        public CstBracedStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBracedStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstElement> Element => Children[0] as CstZeroOrMore<CstElement>;
    }

    // Original Rule: ('['+((Element+WS))*+']')
    // Only Nodes: (Element)*
    // Optimized only nodes: (Element)*
    public class CstBracketedStructure : CstNode
    {
        public CstBracketedStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstBracketedStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstElement> Element => Children[0] as CstZeroOrMore<CstElement>;
    }

    // Original Rule: ('('+((Element+WS))*+')')
    // Only Nodes: (Element)*
    // Optimized only nodes: (Element)*
    public class CstParenthesizedStructure : CstNode
    {
        public CstParenthesizedStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstParenthesizedStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstElement> Element => Children[0] as CstZeroOrMore<CstElement>;
    }

    // Original Rule: ((BracketedStructure+WS)|(ParenthesizedStructure+WS)|(BracedStructure+WS))
    // Only Nodes: (BracketedStructure|ParenthesizedStructure|BracedStructure)
    // Optimized only nodes: (BracketedStructure|ParenthesizedStructure|BracedStructure)
    public class CstStructure : CstChoice
    {
        public CstStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstStructure(Children.Select(f).ToArray());
        public CstBracketedStructure BracketedStructure => Children[0] as CstBracketedStructure;
        public CstParenthesizedStructure ParenthesizedStructure => Children[0] as CstParenthesizedStructure;
        public CstBracedStructure BracedStructure => Children[0] as CstBracedStructure;
    }

    // Original Rule: ((Element+WS))*
    // Only Nodes: (Element)*
    // Optimized only nodes: (Element)*
    public class CstFileStructure : CstNode
    {
        public CstFileStructure(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstFileStructure(Children.Select(f).ToArray());
        public CstZeroOrMore<CstElement> Element => Children[0] as CstZeroOrMore<CstElement>;
    }

    // Original Rule: ((UsingDirective+WS)|(TypeDeclarationWithPreamble+WS)|(Statement+WS))
    // Only Nodes: (UsingDirective|TypeDeclarationWithPreamble|Statement)
    // Optimized only nodes: (UsingDirective|TypeDeclarationWithPreamble|Statement)
    public class CstTypeDirectiveOrStatement : CstChoice
    {
        public CstTypeDirectiveOrStatement(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstTypeDirectiveOrStatement(Children.Select(f).ToArray());
        public CstUsingDirective UsingDirective => Children[0] as CstUsingDirective;
        public CstTypeDeclarationWithPreamble TypeDeclarationWithPreamble => Children[0] as CstTypeDeclarationWithPreamble;
        public CstStatement Statement => Children[0] as CstStatement;
    }

    // Original Rule: (WS+((TypeDirectiveOrStatement+WS))*)
    // Only Nodes: (TypeDirectiveOrStatement)*
    // Optimized only nodes: (TypeDirectiveOrStatement)*
    public class CstScript : CstNode
    {
        public CstScript(params CstNode[] children) : base(children) { }
        public override CstNode Transform(Func<CstNode, CstNode> f) => new CstScript(Children.Select(f).ToArray());
        public CstZeroOrMore<CstTypeDirectiveOrStatement> TypeDirectiveOrStatement => Children[0] as CstZeroOrMore<CstTypeDirectiveOrStatement>;
    }

}
