// DO NOT EDIT: Autogenerated file created on 2023-03-20 11:25:12 PM. 
using System;
using System.Linq;

namespace Parakeet.Demos.CSharp
{
    // Original Rule: (Digits+(FractionalPart)?+(ExponentPart)?+(FloatSuffix)?)
    // Only Nodes: 
    public class FloatLiteral : TypedParseNode
    {
        public FloatLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FloatLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("0x"|"0X")+HexDigit+(HexDigit)*+(IntegerSuffix)?)
    // Only Nodes: 
    public class HexLiteral : TypedParseNode
    {
        public HexLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new HexLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("0b"|("0B"+BinDigit+(BinDigit)*+(IntegerSuffix)?))
    // Only Nodes: 
    public class BinaryLiteral : TypedParseNode
    {
        public BinaryLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BinaryLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (Digits+!([\x2EDFMdfm])+(IntegerSuffix)?)
    // Only Nodes: 
    public class IntegerLiteral : TypedParseNode
    {
        public IntegerLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new IntegerLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (('@')?+'"'+(StringLiteralChar)*+'"')
    // Only Nodes: 
    public class StringLiteral : TypedParseNode
    {
        public StringLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new StringLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('''+CharLiteralChar+''')
    // Only Nodes: 
    public class CharLiteral : TypedParseNode
    {
        public CharLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new CharLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("true"+!(IdentifierChar)+WS)|("false"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class BooleanLiteral : TypedParseNode
    {
        public BooleanLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BooleanLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("null"+!(IdentifierChar)+WS)
    // Only Nodes: 
    public class NullLiteral : TypedParseNode
    {
        public NullLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new NullLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("value"+!(IdentifierChar)+WS)
    // Only Nodes: 
    public class ValueLiteral : TypedParseNode
    {
        public ValueLiteral(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ValueLiteral(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((HexLiteral+WS)|(BinaryLiteral+WS)|(FloatLiteral+WS)|(IntegerLiteral+WS)|(StringLiteral+WS)|(CharLiteral+WS)|(BooleanLiteral+WS)|(NullLiteral+WS)|(ValueLiteral+WS))
    // Only Nodes: ((HexLiteral)|(BinaryLiteral)|(FloatLiteral)|(IntegerLiteral)|(StringLiteral)|(CharLiteral)|(BooleanLiteral)|(NullLiteral)|(ValueLiteral))
    public class Literal : TypedParseChoice
    {
        public Literal(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Literal(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_2 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_3 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_4 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_5 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_6 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_7 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_8 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ((">>>="+WS)|(">>>"+WS)|(">>="+WS)|("<<="+WS)|("\x26\x26="+WS)|("||="+WS)|(">>"+WS)|("<<"+WS)|("\x26\x26"+WS)|("||"+WS)|("+="+WS)|("\x2D="+WS)|("\x2A="+WS)|("\x2F="+WS)|("\x25="+WS)|("\x26="+WS)|("|="+WS)|("^="+WS)|("<="+WS)|(">="+WS)|("=="+WS)|("\x21="+WS)|("\x3F\x3F"+WS)|("\x3F="+WS)|('+'+WS)|('-'+WS)|('*'+WS)|('/'+WS)|('%'+WS)|('&'+WS)|('|'+WS)|('^'+WS)|('='+WS)|('<'+WS)|('>'+WS))
    // Only Nodes: 
    public class BinaryOperator : TypedParseNode
    {
        public BinaryOperator(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BinaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('('+WS+TypeExpr+WS+')'+WS+Expression+WS)
    // Only Nodes: (TypeExpr+Expression)
    public class CastExpression : TypedParseSequence
    {
        public CastExpression(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new CastExpression(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: (("++"+WS)|("\x2D\x2D"+WS)|('!'+WS)|('-'+WS)|('+'+WS)|('~'+WS))
    // Only Nodes: 
    public class UnaryOperator : TypedParseNode
    {
        public UnaryOperator(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new UnaryOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('['+WS+Expression+WS+']'+WS)
    // Only Nodes: (Expression)
    public class Indexer : TypedParseSequence
    {
        public Indexer(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Indexer(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((">>>"+WS)|("++"+WS)|("\x2D\x2D"+WS)|("<<"+WS)|(">>"+WS)|("=="+WS)|("\x21="+WS)|("<="+WS)|(">="+WS)|('+'+WS)|('-'+WS)|('!'+WS)|('~'+WS)|('*'+WS)|('/'+WS)|('%'+WS)|('&'+WS)|('|'+WS)|('^'+WS)|('<'+WS)|('>'+WS))
    // Only Nodes: 
    public class OverloadableOperator : TypedParseNode
    {
        public OverloadableOperator(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new OverloadableOperator(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("++"+WS)|("\x2D\x2D"+WS)|('!'+WS)|(MemberAccess+WS)|(ConditionalMemberAccess+WS)|(FunctionArgs+WS)|(Indexer+WS)|(TernaryOperation+WS)|(BinaryOperation+WS)|(IsOperation+WS)|(AsOperation+WS))
    // Only Nodes: ((MemberAccess)|(ConditionalMemberAccess)|(FunctionArgs)|(Indexer)|(TernaryOperation)|(BinaryOperation)|(IsOperation)|(AsOperation))
    public class PostfixOperator : TypedParseChoice
    {
        public PostfixOperator(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new PostfixOperator(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_2 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_3 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_4 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_5 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_6 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_7 => Children[0] as TypedParseSequence;
    }

    // Original Rule: (IdentifierFirstChar+(IdentifierChar)*)
    // Only Nodes: 
    public class Identifier : TypedParseNode
    {
        public Identifier(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Identifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (!("=>")+BinaryOperator+WS+_RECOVER_+Expression+WS)
    // Only Nodes: (BinaryOperator+Expression)
    public class BinaryOperation : TypedParseSequence
    {
        public BinaryOperation(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BinaryOperation(Children.Select(f).ToArray());
        public BinaryOperator BinaryOperator => Children[0] as BinaryOperator;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: ('?'+WS+_RECOVER_+Expression+WS+':'+WS+Expression+WS)
    // Only Nodes: (Expression+Expression)
    public class TernaryOperation : TypedParseSequence
    {
        public TernaryOperation(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TernaryOperation(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
        public Expression Expression_1 => Children[1] as Expression;
    }

    // Original Rule: ('('+WS+(((Expression+WS+WS+((Comma+Expression+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((Expression+((Expression))*))?)
    public class ParenthesizedExpression : TypedParseSequence
    {
        public ParenthesizedExpression(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ParenthesizedExpression(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("throw"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS)
    // Only Nodes: (Expression)
    public class ThrowExpression : TypedParseSequence
    {
        public ThrowExpression(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ThrowExpression(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ((TypeExpr+WS+Identifier+WS)|(Identifier+WS))
    // Only Nodes: ((TypeExpr+Identifier)|(Identifier))
    public class LambdaParameter : TypedParseChoice
    {
        public LambdaParameter(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new LambdaParameter(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ((LambdaParameter+WS)|('('+WS+(((LambdaParameter+WS+WS+((Comma+LambdaParameter+WS+WS))*)+(Comma)?))?+')'+WS))
    // Only Nodes: ((LambdaParameter)|(((LambdaParameter+((LambdaParameter))*))?))
    public class LambdaParameters : TypedParseChoice
    {
        public LambdaParameters(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new LambdaParameters(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ((CompoundStatement+WS)|(Expression+WS))
    // Only Nodes: ((CompoundStatement)|(Expression))
    public class LambdaBody : TypedParseChoice
    {
        public LambdaBody(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new LambdaBody(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: (LambdaParameters+WS+"=>"+WS+_RECOVER_+LambdaBody+WS)
    // Only Nodes: (LambdaParameters+LambdaBody)
    public class LambdaExpr : TypedParseSequence
    {
        public LambdaExpr(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new LambdaExpr(Children.Select(f).ToArray());
        public LambdaParameters LambdaParameters => Children[0] as LambdaParameters;
        public LambdaBody LambdaBody => Children[1] as LambdaBody;
    }

    // Original Rule: ('.'+WS+Identifier+WS)
    // Only Nodes: (Identifier)
    public class MemberAccess : TypedParseSequence
    {
        public MemberAccess(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new MemberAccess(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
    }

    // Original Rule: ("\x3F\x2E"+WS+Identifier+WS)
    // Only Nodes: (Identifier)
    public class ConditionalMemberAccess : TypedParseSequence
    {
        public ConditionalMemberAccess(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ConditionalMemberAccess(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
    }

    // Original Rule: ("typeof"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+TypeExpr+WS+')'+WS)
    // Only Nodes: (TypeExpr)
    public class TypeOf : TypedParseSequence
    {
        public TypeOf(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeOf(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
    }

    // Original Rule: ("nameof"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+Expression+WS+')'+WS)
    // Only Nodes: (Expression)
    public class NameOf : TypedParseSequence
    {
        public NameOf(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new NameOf(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("default"+!(IdentifierChar)+WS+_RECOVER_+(('('+WS+TypeExpr+WS+')'+WS))?)
    // Only Nodes: (((TypeExpr))?)
    public class Default : TypedParseSequence
    {
        public Default(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Default(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((Identifier+WS+'='+WS+_RECOVER_+Expression+WS)|(Expression+WS))
    // Only Nodes: ((Identifier+Expression)|(Expression))
    public class InitializerClause : TypedParseChoice
    {
        public InitializerClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new InitializerClause(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ('{'+WS+_RECOVER_+(((InitializerClause+WS+WS+((Comma+InitializerClause+WS+WS))*)+(Comma)?))?+'}'+WS)
    // Only Nodes: (((InitializerClause+((InitializerClause))*))?)
    public class Initializer : TypedParseSequence
    {
        public Initializer(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Initializer(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ('['+WS+Expression+WS+']'+WS)
    // Only Nodes: (Expression)
    public class ArraySizeSpecifier : TypedParseSequence
    {
        public ArraySizeSpecifier(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ArraySizeSpecifier(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("new"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((FunctionArgs+WS))?+((ArraySizeSpecifier+WS))?+((Initializer+WS))?)
    // Only Nodes: (TypeExpr+((FunctionArgs))?+((ArraySizeSpecifier))?+((Initializer))?)
    public class NewOperation : TypedParseSequence
    {
        public NewOperation(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new NewOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[1] as TypedParseOptional<TypedParseNode>;
        public TypedParseOptional<TypedParseNode> SequenceRule_1 => Children[2] as TypedParseOptional<TypedParseNode>;
        public TypedParseOptional<TypedParseNode> SequenceRule_2 => Children[3] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("is"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((Identifier+WS))?)
    // Only Nodes: (TypeExpr+((Identifier))?)
    public class IsOperation : TypedParseSequence
    {
        public IsOperation(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new IsOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[1] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("as"+!(IdentifierChar)+WS+_RECOVER_+TypeExpr+WS+((Identifier+WS))?)
    // Only Nodes: (TypeExpr+((Identifier))?)
    public class AsOperation : TypedParseSequence
    {
        public AsOperation(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new AsOperation(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[1] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (('{'+WS+_RECOVER_+Expression+WS+'}'+WS)|StringLiteralChar)
    // Only Nodes: ((Expression))
    public class StringInterpolationContent : TypedParseChoice
    {
        public StringInterpolationContent(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new StringInterpolationContent(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
    }

    // Original Rule: ('$'+_RECOVER_+'"'+((StringInterpolationContent+WS))*+'"')
    // Only Nodes: (((StringInterpolationContent))*)
    public class StringInterpolation : TypedParseSequence
    {
        public StringInterpolation(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new StringInterpolation(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: (("params"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS)|("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class FunctionArgKeyword : TypedParseNode
    {
        public FunctionArgKeyword(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FunctionArgKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (((FunctionArgKeyword+WS))*+Expression+WS)
    // Only Nodes: (((FunctionArgKeyword))*+Expression)
    public class FunctionArg : TypedParseSequence
    {
        public FunctionArg(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FunctionArg(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
        public Expression Expression => Children[1] as Expression;
    }

    // Original Rule: ('('+WS+(((FunctionArg+WS+WS+((Comma+FunctionArg+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((FunctionArg+((FunctionArg))*))?)
    public class FunctionArgs : TypedParseSequence
    {
        public FunctionArgs(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FunctionArgs(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((LambdaExpr+WS)|(CastExpression+WS)|(ParenthesizedExpression+WS)|(ThrowExpression+WS)|(Literal+WS)|(TypeOf+WS)|(NameOf+WS)|(Default+WS)|(NewOperation+WS)|(StringInterpolation+WS)|(Identifier+WS))
    // Only Nodes: ((LambdaExpr)|(CastExpression)|(ParenthesizedExpression)|(ThrowExpression)|(Literal)|(TypeOf)|(NameOf)|(Default)|(NewOperation)|(StringInterpolation)|(Identifier))
    public class LeafExpression : TypedParseChoice
    {
        public LeafExpression(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new LeafExpression(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_2 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_3 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_4 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_5 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_6 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_7 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_8 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_9 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_10 => Children[0] as TypedParseSequence;
    }

    // Original Rule: (((UnaryOperator+WS))*+LeafExpression+WS+((PostfixOperator+WS))*)
    // Only Nodes: (((UnaryOperator))*+LeafExpression+((PostfixOperator))*)
    public class Expression : TypedParseSequence
    {
        public Expression(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Expression(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
        public LeafExpression LeafExpression => Children[1] as LeafExpression;
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule_1 => Children[2] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: (Expression+WS+_RECOVER_+EOS)
    // Only Nodes: (Expression)
    public class ExpressionStatement : TypedParseSequence
    {
        public ExpressionStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ExpressionStatement(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("else"+!(IdentifierChar)+WS+_RECOVER_+Statement+WS)
    // Only Nodes: (Statement)
    public class ElseClause : TypedParseSequence
    {
        public ElseClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ElseClause(Children.Select(f).ToArray());
        public Statement Statement => Children[0] as Statement;
    }

    // Original Rule: ("if"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS+Statement+WS+((ElseClause+WS))?)
    // Only Nodes: (ParenthesizedExpression+Statement+((ElseClause))?)
    public class IfStatement : TypedParseSequence
    {
        public IfStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new IfStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
        public Statement Statement => Children[1] as Statement;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[2] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("while"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS+Statement+WS)
    // Only Nodes: (ParenthesizedExpression+Statement)
    public class WhileStatement : TypedParseSequence
    {
        public WhileStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new WhileStatement(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
        public Statement Statement => Children[1] as Statement;
    }

    // Original Rule: ("do"+!(IdentifierChar)+WS+_RECOVER_+Statement+WS+"while"+!(IdentifierChar)+WS+ParenthesizedExpression+WS+EOS)
    // Only Nodes: (Statement+ParenthesizedExpression)
    public class DoWhileStatement : TypedParseSequence
    {
        public DoWhileStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new DoWhileStatement(Children.Select(f).ToArray());
        public Statement Statement => Children[0] as Statement;
        public ParenthesizedExpression ParenthesizedExpression => Children[1] as ParenthesizedExpression;
    }

    // Original Rule: ("return"+!(IdentifierChar)+WS+_RECOVER_+((Expression+WS))?+EOS)
    // Only Nodes: (((Expression))?)
    public class ReturnStatement : TypedParseSequence
    {
        public ReturnStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ReturnStatement(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("break"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    public class BreakStatement : TypedParseNode
    {
        public BreakStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BreakStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("yield"+!(IdentifierChar)+WS+_RECOVER_+((YieldReturn+WS)|(YieldBreak+WS)))
    // Only Nodes: (((YieldReturn)|(YieldBreak)))
    public class YieldStatement : TypedParseSequence
    {
        public YieldStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new YieldStatement(Children.Select(f).ToArray());
        public TypedParseChoice ChoiceRule => Children[0] as TypedParseChoice;
    }

    // Original Rule: ("return"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS+EOS)
    // Only Nodes: (Expression)
    public class YieldReturn : TypedParseSequence
    {
        public YieldReturn(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new YieldReturn(Children.Select(f).ToArray());
        public Expression Expression => Children[0] as Expression;
    }

    // Original Rule: ("break"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    public class YieldBreak : TypedParseNode
    {
        public YieldBreak(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new YieldBreak(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ("continue"+!(IdentifierChar)+WS+_RECOVER_+EOS)
    // Only Nodes: 
    public class ContinueStatement : TypedParseNode
    {
        public ContinueStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ContinueStatement(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('{'+WS+_RECOVER_+((Statement+WS))*+'}'+WS)
    // Only Nodes: (((Statement))*)
    public class CompoundStatement : TypedParseSequence
    {
        public CompoundStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new CompoundStatement(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ("catch"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+VarDecl+WS+')'+WS+CompoundStatement+WS)
    // Only Nodes: (VarDecl+CompoundStatement)
    public class CatchClause : TypedParseSequence
    {
        public CatchClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new CatchClause(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public CompoundStatement CompoundStatement => Children[1] as CompoundStatement;
    }

    // Original Rule: ("finally"+!(IdentifierChar)+WS+CompoundStatement+WS)
    // Only Nodes: (CompoundStatement)
    public class FinallyClause : TypedParseSequence
    {
        public FinallyClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FinallyClause(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
    }

    // Original Rule: ((("default"+!(IdentifierChar)+WS)|("case"+!(IdentifierChar)+WS+_RECOVER_+Expression+WS))+(Statement+WS))
    // Only Nodes: (((Expression))+Statement)
    public class CaseClause : TypedParseSequence
    {
        public CaseClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new CaseClause(Children.Select(f).ToArray());
        public TypedParseChoice ChoiceRule => Children[0] as TypedParseChoice;
        public Statement Statement => Children[1] as Statement;
    }

    // Original Rule: ("switch"+!(IdentifierChar)+WS+_RECOVER_+'{'+WS+_RECOVER_+((CaseClause+WS))*+'}'+WS)
    // Only Nodes: (((CaseClause))*)
    public class SwitchStatement : TypedParseSequence
    {
        public SwitchStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new SwitchStatement(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ("try"+!(IdentifierChar)+WS+_RECOVER_+CompoundStatement+WS+((CatchClause+WS))?+((FinallyClause+WS))?)
    // Only Nodes: (CompoundStatement+((CatchClause))?+((FinallyClause))?)
    public class TryStatement : TypedParseSequence
    {
        public TryStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TryStatement(Children.Select(f).ToArray());
        public CompoundStatement CompoundStatement => Children[0] as CompoundStatement;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[1] as TypedParseOptional<TypedParseNode>;
        public TypedParseOptional<TypedParseNode> SequenceRule_1 => Children[2] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("foreach"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+VarDecl+WS+"in"+!(IdentifierChar)+WS+Expression+WS+')'+WS+Statement+WS)
    // Only Nodes: (VarDecl+Expression+Statement)
    public class ForEachStatement : TypedParseSequence
    {
        public ForEachStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ForEachStatement(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public Expression Expression => Children[1] as Expression;
        public Statement Statement => Children[2] as Statement;
    }

    // Original Rule: ((VarDecl+WS+Initialization+WS))?
    // Only Nodes: ((VarDecl+Initialization))?
    public class InitializationClause : TypedParseNode
    {
        public InitializationClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new InitializationClause(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((Expression+WS))?
    // Only Nodes: ((Expression))?
    public class InvariantClause : TypedParseNode
    {
        public InvariantClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new InvariantClause(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((Expression+WS))?
    // Only Nodes: ((Expression))?
    public class VariantClause : TypedParseNode
    {
        public VariantClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new VariantClause(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("for"+!(IdentifierChar)+WS+_RECOVER_+'('+WS+InitializationClause+WS+EOS+InvariantClause+WS+EOS+VariantClause+WS+')'+WS+Statement+WS)
    // Only Nodes: (InitializationClause+InvariantClause+VariantClause+Statement)
    public class ForStatement : TypedParseSequence
    {
        public ForStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ForStatement(Children.Select(f).ToArray());
        public InitializationClause InitializationClause => Children[0] as InitializationClause;
        public InvariantClause InvariantClause => Children[1] as InvariantClause;
        public VariantClause VariantClause => Children[2] as VariantClause;
        public Statement Statement => Children[3] as Statement;
    }

    // Original Rule: ('{'+WS+_RECOVER_+(((Expression+WS+WS+((Comma+Expression+WS+WS))*)+(Comma)?))?+'}'+WS)
    // Only Nodes: (((Expression+((Expression))*))?)
    public class ArrayInitializationValue : TypedParseSequence
    {
        public ArrayInitializationValue(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ArrayInitializationValue(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((ArrayInitializationValue+WS)|(Expression+WS))
    // Only Nodes: ((ArrayInitializationValue)|(Expression))
    public class InitializationValue : TypedParseChoice
    {
        public InitializationValue(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new InitializationValue(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: (('='+WS+_RECOVER_+InitializationValue+WS))?
    // Only Nodes: ((InitializationValue))?
    public class Initialization : TypedParseNode
    {
        public Initialization(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Initialization(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS)
    // Only Nodes: (TypeExpr+Identifier)
    public class VarDecl : TypedParseSequence
    {
        public VarDecl(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new VarDecl(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
    }

    // Original Rule: (VarDecl+WS+Initialization+WS+EOS)
    // Only Nodes: (VarDecl+Initialization)
    public class VarDeclStatement : TypedParseSequence
    {
        public VarDeclStatement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new VarDeclStatement(Children.Select(f).ToArray());
        public VarDecl VarDecl => Children[0] as VarDecl;
        public Initialization Initialization => Children[1] as Initialization;
    }

    // Original Rule: (EOS|(CompoundStatement+WS)|(IfStatement+WS)|(WhileStatement+WS)|(DoWhileStatement+WS)|(ReturnStatement+WS)|(BreakStatement+WS)|(ContinueStatement+WS)|(ForStatement+WS)|(ForEachStatement+WS)|(VarDeclStatement+WS)|(TryStatement+WS)|(YieldStatement+WS)|(SwitchStatement+WS)|(ExpressionStatement+WS))
    // Only Nodes: ((CompoundStatement)|(IfStatement)|(WhileStatement)|(DoWhileStatement)|(ReturnStatement)|(BreakStatement)|(ContinueStatement)|(ForStatement)|(ForEachStatement)|(VarDeclStatement)|(TryStatement)|(YieldStatement)|(SwitchStatement)|(ExpressionStatement))
    public class Statement : TypedParseChoice
    {
        public Statement(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Statement(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_2 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_3 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_4 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_5 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_6 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_7 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_8 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_9 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_10 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_11 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_12 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_13 => Children[0] as TypedParseSequence;
    }

    // Original Rule: (((Identifier+WS+WS+(('.'+WS+Identifier+WS+WS))*)+(('.'+WS))?))?
    // Only Nodes: ((Identifier+((Identifier))*))?
    public class QualifiedIdentifier : TypedParseNode
    {
        public QualifiedIdentifier(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new QualifiedIdentifier(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (("static"+!(IdentifierChar)+WS))?
    // Only Nodes: 
    public class Static : TypedParseNode
    {
        public Static(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Static(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((("global"+!(IdentifierChar)+WS))?+"using"+!(IdentifierChar)+WS+_RECOVER_+Static+WS+QualifiedIdentifier+WS+EOS)
    // Only Nodes: (Static+QualifiedIdentifier)
    public class UsingDirective : TypedParseSequence
    {
        public UsingDirective(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new UsingDirective(Children.Select(f).ToArray());
        public Static Static => Children[0] as Static;
        public QualifiedIdentifier QualifiedIdentifier => Children[1] as QualifiedIdentifier;
    }

    // Original Rule: (("readonly"+!(IdentifierChar)+WS)|("abstract"+!(IdentifierChar)+WS)|("partial"+!(IdentifierChar)+WS)|("virtual"+!(IdentifierChar)+WS)|("static"+!(IdentifierChar)+WS)|("sealed"+!(IdentifierChar)+WS)|("const"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class Modifier : TypedParseNode
    {
        public Modifier(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Modifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("protected"+!(IdentifierChar)+WS)|("internal"+!(IdentifierChar)+WS)|("private"+!(IdentifierChar)+WS)|("public"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class AccessSpecifier : TypedParseNode
    {
        public AccessSpecifier(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new AccessSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('['+WS+(((Identifier+WS+((FunctionArgs+WS))?+WS+((Comma+Identifier+WS+((FunctionArgs+WS))?+WS))*)+(Comma)?))?+']'+WS)
    // Only Nodes: (((Identifier+((FunctionArgs))?+((Identifier+((FunctionArgs))?))*))?)
    public class Attribute : TypedParseSequence
    {
        public Attribute(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Attribute(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((Attribute+WS))*
    // Only Nodes: ((Attribute))*
    public class AttributeList : TypedParseNode
    {
        public AttributeList(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new AttributeList(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: (AttributeList+WS+(((Modifier+WS)|(AccessSpecifier+WS)))*)
    // Only Nodes: (AttributeList+(((Modifier)|(AccessSpecifier)))*)
    public class DeclarationPreamble : TypedParseSequence
    {
        public DeclarationPreamble(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new DeclarationPreamble(Children.Select(f).ToArray());
        public AttributeList AttributeList => Children[0] as AttributeList;
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleChoiceRule => Children[1] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ((("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS)))?
    // Only Nodes: 
    public class TypeVariance : TypedParseNode
    {
        public TypeVariance(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeVariance(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (TypeVariance+WS+Identifier+WS)
    // Only Nodes: (TypeVariance+Identifier)
    public class TypeParameter : TypedParseSequence
    {
        public TypeParameter(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeParameter(Children.Select(f).ToArray());
        public TypeVariance TypeVariance => Children[0] as TypeVariance;
        public Identifier Identifier => Children[1] as Identifier;
    }

    // Original Rule: (('<'+WS+(((TypeParameter+WS+WS+((Comma+TypeParameter+WS+WS))*)+(Comma)?))?+'>'+WS))?
    // Only Nodes: ((((TypeParameter+((TypeParameter))*))?))?
    public class TypeParameterList : TypedParseNode
    {
        public TypeParameterList(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeParameterList(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((':'+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?))?
    // Only Nodes: ((((TypeExpr+((TypeExpr))*))?))?
    public class BaseClassList : TypedParseNode
    {
        public BaseClassList(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BaseClassList(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (("class"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|(TypeExpr+WS))
    // Only Nodes: ((TypeExpr))
    public class Constraint : TypedParseChoice
    {
        public Constraint(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Constraint(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
    }

    // Original Rule: ("where"+!(IdentifierChar)+WS+Identifier+WS+':'+WS+TypeExpr+WS)
    // Only Nodes: (Identifier+TypeExpr)
    public class ConstraintClause : TypedParseSequence
    {
        public ConstraintClause(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ConstraintClause(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
        public TypeExpr TypeExpr => Children[1] as TypeExpr;
    }

    // Original Rule: ((ConstraintClause+WS))*
    // Only Nodes: ((ConstraintClause))*
    public class ConstraintList : TypedParseNode
    {
        public ConstraintList(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ConstraintList(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: (("interface"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|("class"+!(IdentifierChar)+WS)|("enum"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class Kind : TypedParseNode
    {
        public Kind(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Kind(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (Kind+WS+_RECOVER_+Identifier+WS+TypeParameterList+WS+BaseClassList+WS+ConstraintList+WS+'{'+WS+_RECOVER_+((MemberDeclaration+WS))*+'}'+WS)
    // Only Nodes: (Kind+Identifier+TypeParameterList+BaseClassList+ConstraintList+((MemberDeclaration))*)
    public class TypeDeclaration : TypedParseSequence
    {
        public TypeDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeDeclaration(Children.Select(f).ToArray());
        public Kind Kind => Children[0] as Kind;
        public Identifier Identifier => Children[1] as Identifier;
        public TypeParameterList TypeParameterList => Children[2] as TypeParameterList;
        public BaseClassList BaseClassList => Children[3] as BaseClassList;
        public ConstraintList ConstraintList => Children[4] as ConstraintList;
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[5] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: (DeclarationPreamble+WS+TypeDeclaration+WS)
    // Only Nodes: (DeclarationPreamble+TypeDeclaration)
    public class TypeDeclarationWithPreamble : TypedParseSequence
    {
        public TypeDeclarationWithPreamble(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeDeclarationWithPreamble(Children.Select(f).ToArray());
        public DeclarationPreamble DeclarationPreamble => Children[0] as DeclarationPreamble;
        public TypeDeclaration TypeDeclaration => Children[1] as TypeDeclaration;
    }

    // Original Rule: ((("params"+!(IdentifierChar)+WS)|("this"+!(IdentifierChar)+WS)|("ref"+!(IdentifierChar)+WS)|("out"+!(IdentifierChar)+WS)|("in"+!(IdentifierChar)+WS)))?
    // Only Nodes: 
    public class FunctionParameterKeywords : TypedParseNode
    {
        public FunctionParameterKeywords(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FunctionParameterKeywords(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (('='+WS+Expression+WS))?
    // Only Nodes: ((Expression))?
    public class DefaultValue : TypedParseNode
    {
        public DefaultValue(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new DefaultValue(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (AttributeList+WS+FunctionParameterKeywords+WS+TypeExpr+WS+Identifier+WS+DefaultValue+WS)
    // Only Nodes: (AttributeList+FunctionParameterKeywords+TypeExpr+Identifier+DefaultValue)
    public class FunctionParameter : TypedParseSequence
    {
        public FunctionParameter(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FunctionParameter(Children.Select(f).ToArray());
        public AttributeList AttributeList => Children[0] as AttributeList;
        public FunctionParameterKeywords FunctionParameterKeywords => Children[1] as FunctionParameterKeywords;
        public TypeExpr TypeExpr => Children[2] as TypeExpr;
        public Identifier Identifier => Children[3] as Identifier;
        public DefaultValue DefaultValue => Children[4] as DefaultValue;
    }

    // Original Rule: ('('+WS+(((FunctionParameter+WS+WS+((Comma+FunctionParameter+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((FunctionParameter+((FunctionParameter))*))?)
    public class FunctionParameterList : TypedParseSequence
    {
        public FunctionParameterList(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FunctionParameterList(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("=>"+WS+_RECOVER_+((Expression+WS+EOS)|(CompoundStatement+WS)))
    // Only Nodes: (((Expression)|(CompoundStatement)))
    public class ExpressionBody : TypedParseSequence
    {
        public ExpressionBody(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ExpressionBody(Children.Select(f).ToArray());
        public TypedParseChoice ChoiceRule => Children[0] as TypedParseChoice;
    }

    // Original Rule: ((ExpressionBody+WS)|(CompoundStatement+WS)|EOS)
    // Only Nodes: ((ExpressionBody)|(CompoundStatement))
    public class FunctionBody : TypedParseChoice
    {
        public FunctionBody(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FunctionBody(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ("base"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS)
    // Only Nodes: (ParenthesizedExpression)
    public class BaseCall : TypedParseSequence
    {
        public BaseCall(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BaseCall(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: ("this"+!(IdentifierChar)+WS+_RECOVER_+ParenthesizedExpression+WS)
    // Only Nodes: (ParenthesizedExpression)
    public class ThisCall : TypedParseSequence
    {
        public ThisCall(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ThisCall(Children.Select(f).ToArray());
        public ParenthesizedExpression ParenthesizedExpression => Children[0] as ParenthesizedExpression;
    }

    // Original Rule: ((':'+WS+((BaseCall+WS)|(ThisCall+WS))))?
    // Only Nodes: ((((BaseCall)|(ThisCall))))?
    public class BaseOrThisCall : TypedParseNode
    {
        public BaseOrThisCall(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BaseOrThisCall(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (Identifier+WS+FunctionParameterList+WS+_RECOVER_+BaseOrThisCall+WS+FunctionBody+WS)
    // Only Nodes: (Identifier+FunctionParameterList+BaseOrThisCall+FunctionBody)
    public class ConstructorDeclaration : TypedParseSequence
    {
        public ConstructorDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ConstructorDeclaration(Children.Select(f).ToArray());
        public Identifier Identifier => Children[0] as Identifier;
        public FunctionParameterList FunctionParameterList => Children[1] as FunctionParameterList;
        public BaseOrThisCall BaseOrThisCall => Children[2] as BaseOrThisCall;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+FunctionParameterList+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (TypeExpr+Identifier+FunctionParameterList+FunctionBody)
    public class MethodDeclaration : TypedParseSequence
    {
        public MethodDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new MethodDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public FunctionParameterList FunctionParameterList => Children[2] as FunctionParameterList;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+((Initialization+WS))?+EOS)
    // Only Nodes: (TypeExpr+Identifier+((Initialization))?)
    public class FieldDeclaration : TypedParseSequence
    {
        public FieldDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FieldDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[2] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ("get"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (FunctionBody)
    public class Getter : TypedParseSequence
    {
        public Getter(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Getter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: ("set"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (FunctionBody)
    public class Setter : TypedParseSequence
    {
        public Setter(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Setter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: ("init"+!(IdentifierChar)+WS+_RECOVER_+FunctionBody+WS)
    // Only Nodes: (FunctionBody)
    public class Initter : TypedParseSequence
    {
        public Initter(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Initter(Children.Select(f).ToArray());
        public FunctionBody FunctionBody => Children[0] as FunctionBody;
    }

    // Original Rule: (((Getter+WS)|(Setter+WS)|(Initter+WS)))*
    // Only Nodes: (((Getter)|(Setter)|(Initter)))*
    public class PropertyClauses : TypedParseNode
    {
        public PropertyClauses(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new PropertyClauses(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleChoiceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ((ExpressionBody+WS)|('{'+WS+_RECOVER_+PropertyClauses+WS+'}'+WS))
    // Only Nodes: ((ExpressionBody)|(PropertyClauses))
    public class PropertyBody : TypedParseChoice
    {
        public PropertyBody(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new PropertyBody(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: (TypeExpr+WS+Identifier+WS+PropertyBody+WS)
    // Only Nodes: (TypeExpr+Identifier+PropertyBody)
    public class PropertyDeclaration : TypedParseSequence
    {
        public PropertyDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new PropertyDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public Identifier Identifier => Children[1] as Identifier;
        public PropertyBody PropertyBody => Children[2] as PropertyBody;
    }

    // Original Rule: (TypeExpr+WS+"this"+!(IdentifierChar)+WS+_RECOVER_+'['+WS+FunctionParameter+WS+']'+WS+PropertyBody+WS)
    // Only Nodes: (TypeExpr+FunctionParameter+PropertyBody)
    public class IndexerDeclaration : TypedParseSequence
    {
        public IndexerDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new IndexerDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public FunctionParameter FunctionParameter => Children[1] as FunctionParameter;
        public PropertyBody PropertyBody => Children[2] as PropertyBody;
    }

    // Original Rule: (TypeExpr+WS+"operator"+!(IdentifierChar)+WS+_RECOVER_+OverloadableOperator+WS+FunctionParameterList+WS+FunctionBody+WS)
    // Only Nodes: (TypeExpr+OverloadableOperator+FunctionParameterList+FunctionBody)
    public class OperatorDeclaration : TypedParseSequence
    {
        public OperatorDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new OperatorDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public OverloadableOperator OverloadableOperator => Children[1] as OverloadableOperator;
        public FunctionParameterList FunctionParameterList => Children[2] as FunctionParameterList;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (("implicit"+!(IdentifierChar)+WS)|("explicit"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class ImplicitOrExplicit : TypedParseNode
    {
        public ImplicitOrExplicit(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ImplicitOrExplicit(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (TypeExpr+WS+ImplicitOrExplicit+WS+"operator"+!(IdentifierChar)+WS+TypeExpr+WS+FunctionBody+WS)
    // Only Nodes: (TypeExpr+ImplicitOrExplicit+TypeExpr+FunctionBody)
    public class ConverterDeclaration : TypedParseSequence
    {
        public ConverterDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ConverterDeclaration(Children.Select(f).ToArray());
        public TypeExpr TypeExpr => Children[0] as TypeExpr;
        public ImplicitOrExplicit ImplicitOrExplicit => Children[1] as ImplicitOrExplicit;
        public TypeExpr TypeExpr_1 => Children[2] as TypeExpr;
        public FunctionBody FunctionBody => Children[3] as FunctionBody;
    }

    // Original Rule: (DeclarationPreamble+WS+((ConstructorDeclaration+WS)|(MethodDeclaration+WS)|(IndexerDeclaration+WS)|(PropertyDeclaration+WS)|(FieldDeclaration+WS)|(OperatorDeclaration+WS)|(ConverterDeclaration+WS)|(TypeDeclaration+WS)))
    // Only Nodes: (DeclarationPreamble+((ConstructorDeclaration)|(MethodDeclaration)|(IndexerDeclaration)|(PropertyDeclaration)|(FieldDeclaration)|(OperatorDeclaration)|(ConverterDeclaration)|(TypeDeclaration)))
    public class MemberDeclaration : TypedParseSequence
    {
        public MemberDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new MemberDeclaration(Children.Select(f).ToArray());
        public DeclarationPreamble DeclarationPreamble => Children[0] as DeclarationPreamble;
        public TypedParseChoice ChoiceRule => Children[1] as TypedParseChoice;
    }

    // Original Rule: ("namespace"+!(IdentifierChar)+WS+_RECOVER_+QualifiedIdentifier+WS+'{'+WS+_RECOVER_+((TypeDeclarationWithPreamble+WS))*+'}'+WS)
    // Only Nodes: (QualifiedIdentifier+((TypeDeclarationWithPreamble))*)
    public class NamespaceDeclaration : TypedParseSequence
    {
        public NamespaceDeclaration(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new NamespaceDeclaration(Children.Select(f).ToArray());
        public QualifiedIdentifier QualifiedIdentifier => Children[0] as QualifiedIdentifier;
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[1] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: (WS+((UsingDirective+WS))*+((NamespaceDeclaration+WS))?)
    // Only Nodes: (((UsingDirective))*+((NamespaceDeclaration))?)
    public class File : TypedParseSequence
    {
        public File(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new File(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[1] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ('['+WS+(Comma)*+']'+WS)
    // Only Nodes: 
    public class ArrayRankSpecifier : TypedParseNode
    {
        public ArrayRankSpecifier(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ArrayRankSpecifier(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((ArrayRankSpecifier+WS))*
    // Only Nodes: ((ArrayRankSpecifier))*
    public class ArrayRankSpecifiers : TypedParseNode
    {
        public ArrayRankSpecifiers(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ArrayRankSpecifiers(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ('<'+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?+'>'+WS)
    // Only Nodes: (((TypeExpr+((TypeExpr))*))?)
    public class TypeArgList : TypedParseSequence
    {
        public TypeArgList(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeArgList(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (('?'+WS))?
    // Only Nodes: 
    public class Nullable : TypedParseNode
    {
        public Nullable(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Nullable(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ('('+WS+(((TypeExpr+WS+WS+((Comma+TypeExpr+WS+WS))*)+(Comma)?))?+')'+WS)
    // Only Nodes: (((TypeExpr+((TypeExpr))*))?)
    public class CompoundTypeExpr : TypedParseSequence
    {
        public CompoundTypeExpr(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new CompoundTypeExpr(Children.Select(f).ToArray());
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[0] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: (((CompoundTypeExpr+WS)|SimpleTypExpr)+((TypeArgList+WS))?+ArrayRankSpecifiers+WS)
    // Only Nodes: (((CompoundTypeExpr)|(QualifiedIdentifier))+((TypeArgList))?+ArrayRankSpecifiers)
    public class InnerTypeExpr : TypedParseSequence
    {
        public InnerTypeExpr(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new InnerTypeExpr(Children.Select(f).ToArray());
        public TypedParseChoice ChoiceRule => Children[0] as TypedParseChoice;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[1] as TypedParseOptional<TypedParseNode>;
        public ArrayRankSpecifiers ArrayRankSpecifiers => Children[2] as ArrayRankSpecifiers;
    }

    // Original Rule: (InnerTypeExpr+WS)
    // Only Nodes: (InnerTypeExpr)
    public class TypeExpr : TypedParseSequence
    {
        public TypeExpr(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeExpr(Children.Select(f).ToArray());
        public InnerTypeExpr InnerTypeExpr => Children[0] as InnerTypeExpr;
    }

    // Original Rule: ([\x2C\x2E\x3B]|(TypeKeyword+WS)|(StatementKeyword+WS))
    // Only Nodes: ((TypeKeyword)|(StatementKeyword))
    public class Separator : TypedParseChoice
    {
        public Separator(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Separator(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: (("interface"+!(IdentifierChar)+WS)|("struct"+!(IdentifierChar)+WS)|("class"+!(IdentifierChar)+WS)|("enum"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class TypeKeyword : TypedParseNode
    {
        public TypeKeyword(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: (("continue"+!(IdentifierChar)+WS)|("foreach"+!(IdentifierChar)+WS)|("finally"+!(IdentifierChar)+WS)|("default"+!(IdentifierChar)+WS)|("return"+!(IdentifierChar)+WS)|("switch"+!(IdentifierChar)+WS)|("break"+!(IdentifierChar)+WS)|("throw"+!(IdentifierChar)+WS)|("catch"+!(IdentifierChar)+WS)|("using"+!(IdentifierChar)+WS)|("case"+!(IdentifierChar)+WS)|("for"+!(IdentifierChar)+WS)|("try"+!(IdentifierChar)+WS)|("if"+!(IdentifierChar)+WS)|("do"+!(IdentifierChar)+WS))
    // Only Nodes: 
    public class StatementKeyword : TypedParseNode
    {
        public StatementKeyword(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new StatementKeyword(Children.Select(f).ToArray());
        // No children
    }

    // Original Rule: ((Separator+WS)|CppStyleComment|Spaces|([\x21\x23-\x26\x2A+\x2D\x2F\x3A<-\x40^|~]+([\x21\x23-\x26\x2A+\x2D\x2F\x3A<-\x40^|~])*)|(Identifier+WS)|(Literal+WS))
    // Only Nodes: ((Separator)|(Identifier)|(Literal))
    public class Token : TypedParseChoice
    {
        public Token(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Token(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_2 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ((!([\x28\x29\x5B\x5D\x7B\x7D])+((Token+WS)|(Separator+WS)))+((!([\x28\x29\x5B\x5D\x7B\x7D])+((Token+WS)|(Separator+WS))))*)
    // Only Nodes: (((Token)|(Separator))+((((Token)|(Separator))))*)
    public class TokenGroup : TypedParseSequence
    {
        public TokenGroup(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TokenGroup(Children.Select(f).ToArray());
        public TypedParseChoice ChoiceRule => Children[0] as TypedParseChoice;
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[1] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: (TypeKeyword+WS+TokenGroup+WS+BracedStructure+WS)
    // Only Nodes: (TypeKeyword+TokenGroup+BracedStructure)
    public class TypeStructure : TypedParseSequence
    {
        public TypeStructure(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new TypeStructure(Children.Select(f).ToArray());
        public TypeKeyword TypeKeyword => Children[0] as TypeKeyword;
        public TokenGroup TokenGroup => Children[1] as TokenGroup;
        public BracedStructure BracedStructure => Children[2] as BracedStructure;
    }

    // Original Rule: (StatementKeyword+WS+TokenGroup+WS+((BracedStructure+WS))?)
    // Only Nodes: (StatementKeyword+TokenGroup+((BracedStructure))?)
    public class StatementStructure : TypedParseSequence
    {
        public StatementStructure(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new StatementStructure(Children.Select(f).ToArray());
        public StatementKeyword StatementKeyword => Children[0] as StatementKeyword;
        public TokenGroup TokenGroup => Children[1] as TokenGroup;
        public TypedParseOptional<TypedParseNode> SequenceRule => Children[2] as TypedParseOptional<TypedParseNode>;
    }

    // Original Rule: ((Structure+WS)|(TokenGroup+WS))
    // Only Nodes: ((Structure)|(TokenGroup))
    public class Element : TypedParseChoice
    {
        public Element(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Element(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ('{'+((Element+WS))*+'}')
    // Only Nodes: (((Element))*)
    public class BracedStructure : TypedParseSequence
    {
        public BracedStructure(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BracedStructure(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ('['+((Element+WS))*+']')
    // Only Nodes: (((Element))*)
    public class BracketedStructure : TypedParseSequence
    {
        public BracketedStructure(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new BracketedStructure(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ('('+((Element+WS))*+')')
    // Only Nodes: (((Element))*)
    public class ParenthesizedStructure : TypedParseSequence
    {
        public ParenthesizedStructure(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new ParenthesizedStructure(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    // Original Rule: ((BracketedStructure+WS)|(ParenthesizedStructure+WS)|(BracedStructure+WS))
    // Only Nodes: ((BracketedStructure)|(ParenthesizedStructure)|(BracedStructure))
    public class Structure : TypedParseChoice
    {
        public Structure(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new Structure(Children.Select(f).ToArray());
        public TypedParseSequence SequenceRule => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_1 => Children[0] as TypedParseSequence;
        public TypedParseSequence SequenceRule_2 => Children[0] as TypedParseSequence;
    }

    // Original Rule: ((Element+WS))*
    // Only Nodes: ((Element))*
    public class FileStructure : TypedParseNode
    {
        public FileStructure(params TypedParseNode[] children) : base(children) { }
        public override TypedParseNode Transform(Func<TypedParseNode, TypedParseNode> f) => new FileStructure(Children.Select(f).ToArray());
        public TypedParseZeroOrMore<TypedParseNode> ZeroOrMoreRuleSequenceRule => Children[0] as TypedParseZeroOrMore<TypedParseNode>;
    }

    public static class ParseNodeClassFactory
    {
        public static TypedParseNode Create(ParserTree node)
        {
            switch (node.Type)
            {
                default: throw new Exception($"Unrecognized parse node {node.Type}");
            }
        }
    }
}
