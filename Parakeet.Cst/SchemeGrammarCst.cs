// DO NOT EDIT: Autogenerated file created on 2024-06-03 7:58:24 PM. 
using System;
using System.Linq;

namespace Ara3D.Parakeet.Cst.SchemeGrammarNameSpace
{
    /// <summary>This interface exists to make it easy to auto-generate type switches</summary>
    public interface ISchemeCstNode { }

    /// <summary>
    /// Rule = Abbreviation ::= ((AbbrevPrefix+Datum)+WS)
    /// Nodes = (AbbrevPrefix+Datum)
    /// </summary>
    public class CstAbbreviation : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Abbreviation;
        public CstAbbreviation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstAbbrevPrefix> AbbrevPrefix => new CstNodeFilter<CstAbbrevPrefix> (Children);
        public CstNodeFilter<CstDatum> Datum => new CstNodeFilter<CstDatum> (Children);
    }

    /// <summary>
    /// Rule = AbbrevPrefix ::= (([\x27\x2C`]|"\x2C\x40")+WS)
    /// Nodes = 
    /// </summary>
    public class CstAbbrevPrefix : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.AbbrevPrefix;
        public CstAbbrevPrefix(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Alternate ::= ((Expression)?+WS)
    /// Nodes = (Expression)?
    /// </summary>
    public class CstAlternate : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Alternate;
        public CstAlternate(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = AndKeyword ::= (Keyword('and')+WS)
    /// Nodes = 
    /// </summary>
    public class CstAndKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.AndKeyword;
        public CstAndKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Assignment ::= ((Keyword('set!')+Variable+Expression)+WS)
    /// Nodes = (Variable+Expression)
    /// </summary>
    public class CstAssignment : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Assignment;
        public CstAssignment(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = BeginKeyword ::= (Keyword('begin')+WS)
    /// Nodes = 
    /// </summary>
    public class CstBeginKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BeginKeyword;
        public CstBeginKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = BindingSpec ::= (('('+WS+_UNKNOWN_+Variable+Expression+WS+')'+WS)+WS)
    /// Nodes = (Variable+Expression)
    /// </summary>
    public class CstBindingSpec : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BindingSpec;
        public CstBindingSpec(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = Body ::= (((Definition)*+Sequence)+WS)
    /// Nodes = ((Definition)*+Sequence)
    /// </summary>
    public class CstBody : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Body;
        public CstBody(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstDefinition> Definition => new CstNodeFilter<CstDefinition> (Children);
        public CstNodeFilter<CstSequence> Sequence => new CstNodeFilter<CstSequence> (Children);
    }

    /// <summary>
    /// Rule = CaseClause ::= (('('+WS+_UNKNOWN_+'('+WS+_UNKNOWN_+(Datum)*+WS+')'+WS+Sequence+WS+')'+WS)+WS)
    /// Nodes = ((Datum)*+Sequence)
    /// </summary>
    public class CstCaseClause : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CaseClause;
        public CstCaseClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstDatum> Datum => new CstNodeFilter<CstDatum> (Children);
        public CstNodeFilter<CstSequence> Sequence => new CstNodeFilter<CstSequence> (Children);
    }

    /// <summary>
    /// Rule = CaseKeyword ::= (Keyword('case')+WS)
    /// Nodes = 
    /// </summary>
    public class CstCaseKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CaseKeyword;
        public CstCaseKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Command ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstCommand : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Command;
        public CstCommand(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = CompoundDatum ::= ((List|Vector)+WS)
    /// Nodes = (List|Vector)
    /// </summary>
    public class CstCompoundDatum : CstNodeChoice, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CompoundDatum;
        public CstCompoundDatum(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstList> List => new CstNodeFilter<CstList> (Children);
        public CstNodeFilter<CstVector> Vector => new CstNodeFilter<CstVector> (Children);
    }

    /// <summary>
    /// Rule = CondClause ::= ((('('+WS+_UNKNOWN_+Test+Sequence+WS+')'+WS)|('('+WS+_UNKNOWN_+Test+WS+')'+WS)|('('+WS+_UNKNOWN_+Test+Symbol('=>')+Recipient+WS+')'+WS))+WS)
    /// Nodes = (Test+(Sequence|Recipient))
    /// </summary>
    public class CstCondClause : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CondClause;
        public CstCondClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTest> Test => new CstNodeFilter<CstTest> (Children);
        public CstNodeFilter<CstSequence> Sequence => new CstNodeFilter<CstSequence> (Children);
        public CstNodeFilter<CstRecipient> Recipient => new CstNodeFilter<CstRecipient> (Children);
    }

    /// <summary>
    /// Rule = Conditional ::= ((Keyword('if')+Test+Consequent+Alternate)+WS)
    /// Nodes = (Test+Consequent+Alternate)
    /// </summary>
    public class CstConditional : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Conditional;
        public CstConditional(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstTest> Test => new CstNodeFilter<CstTest> (Children);
        public CstNodeFilter<CstConsequent> Consequent => new CstNodeFilter<CstConsequent> (Children);
        public CstNodeFilter<CstAlternate> Alternate => new CstNodeFilter<CstAlternate> (Children);
    }

    /// <summary>
    /// Rule = CondKeyword ::= (Keyword('cond')+WS)
    /// Nodes = 
    /// </summary>
    public class CstCondKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CondKeyword;
        public CstCondKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Consequent ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstConsequent : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Consequent;
        public CstConsequent(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = Datum ::= (InnerDatum+WS)
    /// Nodes = InnerDatum
    /// </summary>
    public class CstDatum : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Datum;
        public CstDatum(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInnerDatum> InnerDatum => new CstNodeFilter<CstInnerDatum> (Children);
    }

    /// <summary>
    /// Rule = DefFormals ::= (((Variable)*|((Variable)++Symbol('.')+Variable))+WS)
    /// Nodes = (Variable)*
    /// </summary>
    public class CstDefFormals : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.DefFormals;
        public CstDefFormals(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
    }

    /// <summary>
    /// Rule = Definition ::= (InnerDefinition+WS)
    /// Nodes = InnerDefinition
    /// </summary>
    public class CstDefinition : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Definition;
        public CstDefinition(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInnerDefinition> InnerDefinition => new CstNodeFilter<CstInnerDefinition> (Children);
    }

    /// <summary>
    /// Rule = DelayKeyword ::= (Keyword('delay')+WS)
    /// Nodes = 
    /// </summary>
    public class CstDelayKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.DelayKeyword;
        public CstDelayKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Delimiter ::= ((WS|'('|')'|'"'|';')+WS)
    /// Nodes = 
    /// </summary>
    public class CstDelimiter : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Delimiter;
        public CstDelimiter(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = DerivedExpression ::= ((('('+WS+_UNKNOWN_+((CondKeyword+(CondClause)+)|(CondKeyword+(CondClause)*+ElseClause))+WS+')'+WS)|(CaseKeyword+Expression+(CaseClause)+)|(CaseKeyword+(CaseClause)*+ElseClause)|(AndKeyword+(Test)*)|(OrKeyword+(Test)*)|(LetKeyword+'('+WS+_UNKNOWN_+(BindingSpec)*+WS+')'+WS+Body)|(LetKeyword+Variable+'('+WS+_UNKNOWN_+(BindingSpec)*+WS+')'+WS+Body)|(LetStarKeyword+'('+WS+_UNKNOWN_+(BindingSpec)*+WS+')'+WS+Body)|(LetRecKeyword+'('+WS+_UNKNOWN_+(BindingSpec)*+WS+')'+WS+Body)|(BeginKeyword+Sequence)|(DoKeyword+'('+WS+_UNKNOWN_+(IterationSpec)*+WS+')'+WS+'('+WS+_UNKNOWN_+Test+Sequence+WS+')'+WS+(Command)*)|(DelayKeyword+Expression))+WS)
    /// Nodes = ((CondKeyword+((CondClause)+|((CondClause)*+ElseClause)))|(CaseKeyword+((Expression+(CaseClause)+)|((CaseClause)*+ElseClause)))|(AndKeyword+(Test)*)|(OrKeyword+(Test)*)|(LetKeyword+(((BindingSpec)*+Body)|(Variable+(BindingSpec)*+Body)))|(LetStarKeyword+(BindingSpec)*+Body)|(LetRecKeyword+(BindingSpec)*+Body)|(BeginKeyword+Sequence)|(DoKeyword+(IterationSpec)*+Test+Sequence+(Command)*)|(DelayKeyword+Expression))
    /// </summary>
    public class CstDerivedExpression : CstNodeChoice, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.DerivedExpression;
        public CstDerivedExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCondKeyword> CondKeyword => new CstNodeFilter<CstCondKeyword> (Children);
        public CstNodeFilter<CstCondClause> CondClause => new CstNodeFilter<CstCondClause> (Children);
        public CstNodeFilter<CstElseClause> ElseClause => new CstNodeFilter<CstElseClause> (Children);
        public CstNodeFilter<CstCaseKeyword> CaseKeyword => new CstNodeFilter<CstCaseKeyword> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
        public CstNodeFilter<CstCaseClause> CaseClause => new CstNodeFilter<CstCaseClause> (Children);
        public CstNodeFilter<CstAndKeyword> AndKeyword => new CstNodeFilter<CstAndKeyword> (Children);
        public CstNodeFilter<CstTest> Test => new CstNodeFilter<CstTest> (Children);
        public CstNodeFilter<CstOrKeyword> OrKeyword => new CstNodeFilter<CstOrKeyword> (Children);
        public CstNodeFilter<CstLetKeyword> LetKeyword => new CstNodeFilter<CstLetKeyword> (Children);
        public CstNodeFilter<CstBindingSpec> BindingSpec => new CstNodeFilter<CstBindingSpec> (Children);
        public CstNodeFilter<CstBody> Body => new CstNodeFilter<CstBody> (Children);
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
        public CstNodeFilter<CstLetStarKeyword> LetStarKeyword => new CstNodeFilter<CstLetStarKeyword> (Children);
        public CstNodeFilter<CstLetRecKeyword> LetRecKeyword => new CstNodeFilter<CstLetRecKeyword> (Children);
        public CstNodeFilter<CstBeginKeyword> BeginKeyword => new CstNodeFilter<CstBeginKeyword> (Children);
        public CstNodeFilter<CstSequence> Sequence => new CstNodeFilter<CstSequence> (Children);
        public CstNodeFilter<CstDoKeyword> DoKeyword => new CstNodeFilter<CstDoKeyword> (Children);
        public CstNodeFilter<CstIterationSpec> IterationSpec => new CstNodeFilter<CstIterationSpec> (Children);
        public CstNodeFilter<CstCommand> Command => new CstNodeFilter<CstCommand> (Children);
        public CstNodeFilter<CstDelayKeyword> DelayKeyword => new CstNodeFilter<CstDelayKeyword> (Children);
    }

    /// <summary>
    /// Rule = DoKeyword ::= (Keyword('do')+WS)
    /// Nodes = 
    /// </summary>
    public class CstDoKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.DoKeyword;
        public CstDoKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = ElseClause ::= (('('+WS+_UNKNOWN_+ElseKeyword+Sequence+WS+')'+WS)+WS)
    /// Nodes = (ElseKeyword+Sequence)
    /// </summary>
    public class CstElseClause : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ElseClause;
        public CstElseClause(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstElseKeyword> ElseKeyword => new CstNodeFilter<CstElseKeyword> (Children);
        public CstNodeFilter<CstSequence> Sequence => new CstNodeFilter<CstSequence> (Children);
    }

    /// <summary>
    /// Rule = ElseKeyword ::= (Keyword('else')+WS)
    /// Nodes = 
    /// </summary>
    public class CstElseKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ElseKeyword;
        public CstElseKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Expression ::= (InnerExpression+WS)
    /// Nodes = InnerExpression
    /// </summary>
    public class CstExpression : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Expression;
        public CstExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstInnerExpression> InnerExpression => new CstNodeFilter<CstInnerExpression> (Children);
    }

    /// <summary>
    /// Rule = Formals ::= ((('('+WS+_UNKNOWN_+(Variable)*+WS+')'+WS)|Variable|('('+WS+_UNKNOWN_+(Variable)++Symbol('.')+Variable+WS+')'+WS))+WS)
    /// Nodes = (Variable)*
    /// </summary>
    public class CstFormals : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Formals;
        public CstFormals(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
    }

    /// <summary>
    /// Rule = Identifier ::= ((((Keyword('...')|Keyword('+')|Keyword('-'))+!((Letter|"\x21$\x25\x26\x2A\x2F\x3A<=>\x3F\x5F^"|Digit|[+\x2D\x2E])))|((Letter|"\x21$\x25\x26\x2A\x2F\x3A<=>\x3F\x5F^")+((Letter|"\x21$\x25\x26\x2A\x2F\x3A<=>\x3F\x5F^"|Digit|[+\x2D\x2E]))*))+WS)
    /// Nodes = 
    /// </summary>
    public class CstIdentifier : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Identifier;
        public CstIdentifier(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Init ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstInit : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Init;
        public CstInit(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = InnerDatum ::= ((SimpleDatum|CompoundDatum)+WS)
    /// Nodes = (SimpleDatum|CompoundDatum)
    /// </summary>
    public class CstInnerDatum : CstNodeChoice, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InnerDatum;
        public CstInnerDatum(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstSimpleDatum> SimpleDatum => new CstNodeFilter<CstSimpleDatum> (Children);
        public CstNodeFilter<CstCompoundDatum> CompoundDatum => new CstNodeFilter<CstCompoundDatum> (Children);
    }

    /// <summary>
    /// Rule = InnerDefinition ::= ((('('+WS+_UNKNOWN_+Keyword('define')+Variable+Expression+WS+')'+WS)|('('+WS+_UNKNOWN_+Keyword('define')+'('+WS+_UNKNOWN_+Variable+DefFormals+WS+')'+WS+Body+WS+')'+WS)|('('+WS+_UNKNOWN_+Keyword('begin')+(Definition)*+WS+')'+WS))+WS)
    /// Nodes = ((Variable+(Expression|(DefFormals+Body)))|(Definition)*)
    /// </summary>
    public class CstInnerDefinition : CstNodeChoice, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InnerDefinition;
        public CstInnerDefinition(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
        public CstNodeFilter<CstDefFormals> DefFormals => new CstNodeFilter<CstDefFormals> (Children);
        public CstNodeFilter<CstBody> Body => new CstNodeFilter<CstBody> (Children);
        public CstNodeFilter<CstDefinition> Definition => new CstNodeFilter<CstDefinition> (Children);
    }

    /// <summary>
    /// Rule = InnerExpression ::= ((Variable|Literal|ProcedureCall|LambdaExpression|Conditional|Assignment|DerivedExpression)+WS)
    /// Nodes = (Variable|Literal|ProcedureCall|LambdaExpression|Conditional|Assignment|DerivedExpression)
    /// </summary>
    public class CstInnerExpression : CstNodeChoice, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.InnerExpression;
        public CstInnerExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
        public CstNodeFilter<CstLiteral> Literal => new CstNodeFilter<CstLiteral> (Children);
        public CstNodeFilter<CstProcedureCall> ProcedureCall => new CstNodeFilter<CstProcedureCall> (Children);
        public CstNodeFilter<CstLambdaExpression> LambdaExpression => new CstNodeFilter<CstLambdaExpression> (Children);
        public CstNodeFilter<CstConditional> Conditional => new CstNodeFilter<CstConditional> (Children);
        public CstNodeFilter<CstAssignment> Assignment => new CstNodeFilter<CstAssignment> (Children);
        public CstNodeFilter<CstDerivedExpression> DerivedExpression => new CstNodeFilter<CstDerivedExpression> (Children);
    }

    /// <summary>
    /// Rule = IterationSpec ::= ((('('+WS+_UNKNOWN_+Variable+Init+Step+WS+')'+WS)|('('+WS+_UNKNOWN_+Variable+Init+WS+')'+WS))+WS)
    /// Nodes = (Variable+Init+Step)
    /// </summary>
    public class CstIterationSpec : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.IterationSpec;
        public CstIterationSpec(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstVariable> Variable => new CstNodeFilter<CstVariable> (Children);
        public CstNodeFilter<CstInit> Init => new CstNodeFilter<CstInit> (Children);
        public CstNodeFilter<CstStep> Step => new CstNodeFilter<CstStep> (Children);
    }

    /// <summary>
    /// Rule = LambdaExpression ::= (('('+WS+_UNKNOWN_+Keyword('lambda')+Formals+Body+WS+')'+WS)+WS)
    /// Nodes = (Formals+Body)
    /// </summary>
    public class CstLambdaExpression : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LambdaExpression;
        public CstLambdaExpression(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstFormals> Formals => new CstNodeFilter<CstFormals> (Children);
        public CstNodeFilter<CstBody> Body => new CstNodeFilter<CstBody> (Children);
    }

    /// <summary>
    /// Rule = LetKeyword ::= (Keyword('let')+WS)
    /// Nodes = 
    /// </summary>
    public class CstLetKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LetKeyword;
        public CstLetKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = LetRecKeyword ::= (Keyword('letrec')+WS)
    /// Nodes = 
    /// </summary>
    public class CstLetRecKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LetRecKeyword;
        public CstLetRecKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = LetStarKeyword ::= (Keyword('let*')+WS)
    /// Nodes = 
    /// </summary>
    public class CstLetStarKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.LetStarKeyword;
        public CstLetStarKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = List ::= ((('('+WS+_UNKNOWN_+(Datum)*+WS+')'+WS)|('('+WS+_UNKNOWN_+(Datum)++Symbol('.')+Datum+WS+')'+WS)|Abbreviation)+WS)
    /// Nodes = (Datum)*
    /// </summary>
    public class CstList : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.List;
        public CstList(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstDatum> Datum => new CstNodeFilter<CstDatum> (Children);
    }

    /// <summary>
    /// Rule = Literal ::= ((Quotation|SelfEvaluating)+WS)
    /// Nodes = (Quotation|SelfEvaluating)
    /// </summary>
    public class CstLiteral : CstNodeChoice, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Literal;
        public CstLiteral(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstQuotation> Quotation => new CstNodeFilter<CstQuotation> (Children);
        public CstNodeFilter<CstSelfEvaluating> SelfEvaluating => new CstNodeFilter<CstSelfEvaluating> (Children);
    }

    /// <summary>
    /// Rule = Operand ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstOperand : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Operand;
        public CstOperand(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = Operator ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstOperator : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Operator;
        public CstOperator(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = OrKeyword ::= (Keyword('or')+WS)
    /// Nodes = 
    /// </summary>
    public class CstOrKeyword : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.OrKeyword;
        public CstOrKeyword(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = ProcedureCall ::= (('('+WS+_UNKNOWN_+Operator+(Operand)*+WS+')'+WS)+WS)
    /// Nodes = (Operator+(Operand)*)
    /// </summary>
    public class CstProcedureCall : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ProcedureCall;
        public CstProcedureCall(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstOperator> Operator => new CstNodeFilter<CstOperator> (Children);
        public CstNodeFilter<CstOperand> Operand => new CstNodeFilter<CstOperand> (Children);
    }

    /// <summary>
    /// Rule = Program ::= (((Command|Definition))*+WS)
    /// Nodes = ((Command|Definition))*
    /// </summary>
    public class CstProgram : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Program;
        public CstProgram(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCommand> Command => new CstNodeFilter<CstCommand> (Children);
        public CstNodeFilter<CstDefinition> Definition => new CstNodeFilter<CstDefinition> (Children);
    }

    /// <summary>
    /// Rule = Quotation ::= ((('''+Datum)|(Keyword('quote')+Datum))+WS)
    /// Nodes = (Datum|Datum)
    /// </summary>
    public class CstQuotation : CstNodeChoice, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Quotation;
        public CstQuotation(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstDatum> Datum => new CstNodeFilter<CstDatum> (Children);
    }

    /// <summary>
    /// Rule = Recipient ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstRecipient : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Recipient;
        public CstRecipient(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = SelfEvaluating ::= ((((Keyword('#t')|Keyword('#f'))+!((Letter|"\x21$\x25\x26\x2A\x2F\x3A<=>\x3F\x5F^"|Digit|[+\x2D\x2E])))|(Digit)*|("\x5C\x23"+(Keyword('newline')|Keyword('space')))|("\x5C\x23"+AnyChar)|('"'+((!([\x22\x5C])+AnyChar))*+'"'))+WS)
    /// Nodes = 
    /// </summary>
    public class CstSelfEvaluating : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.SelfEvaluating;
        public CstSelfEvaluating(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Sequence ::= (((Command)*+Expression)+WS)
    /// Nodes = ((Command)*+Expression)
    /// </summary>
    public class CstSequence : CstNodeSequence, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Sequence;
        public CstSequence(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstCommand> Command => new CstNodeFilter<CstCommand> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = SimpleDatum ::= ((((Keyword('#t')|Keyword('#f'))+!((Letter|"\x21$\x25\x26\x2A\x2F\x3A<=>\x3F\x5F^"|Digit|[+\x2D\x2E])))|(Digit)*|("\x5C\x23"+(Keyword('newline')|Keyword('space')))|("\x5C\x23"+AnyChar)|('"'+((!([\x22\x5C])+AnyChar))*+'"')|Symbol)+WS)
    /// Nodes = 
    /// </summary>
    public class CstSimpleDatum : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.SimpleDatum;
        public CstSimpleDatum(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Step ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstStep : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Step;
        public CstStep(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = Symbol ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstSymbol : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Symbol;
        public CstSymbol(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = Test ::= (Expression+WS)
    /// Nodes = Expression
    /// </summary>
    public class CstTest : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Test;
        public CstTest(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Rule = Token ::= ((IdentifierChar|((Keyword('#t')|Keyword('#f'))+!((Letter|"\x21$\x25\x26\x2A\x2F\x3A<=>\x3F\x5F^"|Digit|[+\x2D\x2E])))|(Digit)*|("\x5C\x23"+(Keyword('newline')|Keyword('space')))|("\x5C\x23"+AnyChar)|('"'+((!([\x22\x5C])+AnyChar))*+'"')|'('|')'|"\x23\x28"|'''|"`\x7B"|','|'.')+WS)
    /// Nodes = 
    /// </summary>
    public class CstToken : CstNodeLeaf, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Token;
        public CstToken(ILocation location, string text) : base(location, text) { }
    }

    /// <summary>
    /// Rule = Variable ::= (Identifier+WS)
    /// Nodes = Identifier
    /// </summary>
    public class CstVariable : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Variable;
        public CstVariable(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = Vector ::= (('#'+'('+WS+_UNKNOWN_+(Datum)*+WS+')'+WS)+WS)
    /// Nodes = (Datum)*
    /// </summary>
    public class CstVector : CstNode, ISchemeCstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Vector;
        public CstVector(ILocation location, params CstNode[] children) : base(location, children) { }
        public CstNodeFilter<CstDatum> Datum => new CstNodeFilter<CstDatum> (Children);
    }

}
