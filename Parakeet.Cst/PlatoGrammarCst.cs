// DO NOT EDIT: Autogenerated file created on 2024-01-27 10:00:20 AM. 
using System;
using System.Linq;

namespace Ara3D.Parakeet.Cst.PlatoGrammarNameSpace
{
    /// <summary>
    /// Nodes = (Expression)*
    /// </summary>
    public class CstArrayInitializationValue : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArrayInitializationValue;
        public CstArrayInitializationValue(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstArrayRankSpecifier : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArrayRankSpecifier;
        public CstArrayRankSpecifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (ArrayRankSpecifier)*
    /// </summary>
    public class CstArrayRankSpecifiers : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArrayRankSpecifiers;
        public CstArrayRankSpecifiers(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstArrayRankSpecifier> ArrayRankSpecifier => new CstNodeFilter<CstArrayRankSpecifier> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstArraySizeSpecifier : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ArraySizeSpecifier;
        public CstArraySizeSpecifier(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+(Identifier)?)
    /// </summary>
    public class CstAsOperation : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.AsOperation;
        public CstAsOperation(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBinaryLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BinaryLiteral;
        public CstBinaryLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (BinaryOperator+Expression)
    /// </summary>
    public class CstBinaryOperation : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.BinaryOperation;
        public CstBinaryOperation(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstBinaryOperator> BinaryOperator => new CstNodeFilter<CstBinaryOperator> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBinaryOperator : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BinaryOperator;
        public CstBinaryOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBooleanLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BooleanLiteral;
        public CstBooleanLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstBreakStatement : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.BreakStatement;
        public CstBreakStatement(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Expression+Statement)
    /// </summary>
    public class CstCaseClause : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.CaseClause;
        public CstCaseClause(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr+Expression)
    /// </summary>
    public class CstCastExpression : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.CastExpression;
        public CstCastExpression(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (VarDecl+CompoundStatement)
    /// </summary>
    public class CstCatchClause : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.CatchClause;
        public CstCatchClause(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstVarDecl> VarDecl => new CstNodeFilter<CstVarDecl> (Children);
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstCharLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.CharLiteral;
        public CstCharLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (CompoundTypeExpr|SimpleTypeExpr|TypeVar)
    /// </summary>
    public class CstCompoundOrSimpleTypeExpr : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.CompoundOrSimpleTypeExpr;
        public CstCompoundOrSimpleTypeExpr(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstCompoundTypeExpr> CompoundTypeExpr => new CstNodeFilter<CstCompoundTypeExpr> (Children);
        public CstNodeFilter<CstSimpleTypeExpr> SimpleTypeExpr => new CstNodeFilter<CstSimpleTypeExpr> (Children);
        public CstNodeFilter<CstTypeVar> TypeVar => new CstNodeFilter<CstTypeVar> (Children);
    }

    /// <summary>
    /// Nodes = (Statement)*
    /// </summary>
    public class CstCompoundStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.CompoundStatement;
        public CstCompoundStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstCompoundTypeExpr : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.CompoundTypeExpr;
        public CstCompoundTypeExpr(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+TypeParameterList+ConstraintList+InheritsList+(MethodDeclaration)*)
    /// </summary>
    public class CstConcept : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Concept;
        public CstConcept(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeParameterList> TypeParameterList => new CstNodeFilter<CstTypeParameterList> (Children);
        public CstNodeFilter<CstConstraintList> ConstraintList => new CstNodeFilter<CstConstraintList> (Children);
        public CstNodeFilter<CstInheritsList> InheritsList => new CstNodeFilter<CstInheritsList> (Children);
        public CstNodeFilter<CstMethodDeclaration> MethodDeclaration => new CstNodeFilter<CstMethodDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstConditionalMemberAccess : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ConditionalMemberAccess;
        public CstConditionalMemberAccess(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+TypeAnnotation)
    /// </summary>
    public class CstConstraint : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Constraint;
        public CstConstraint(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeAnnotation> TypeAnnotation => new CstNodeFilter<CstTypeAnnotation> (Children);
    }

    /// <summary>
    /// Nodes = (Constraint)*
    /// </summary>
    public class CstConstraintList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ConstraintList;
        public CstConstraintList(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstConstraint> Constraint => new CstNodeFilter<CstConstraint> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstContinueStatement : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.ContinueStatement;
        public CstContinueStatement(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr)?
    /// </summary>
    public class CstDefault : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Default;
        public CstDefault(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstDelimiter : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Delimiter;
        public CstDelimiter(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Statement+ParenthesizedExpression)
    /// </summary>
    public class CstDoWhileStatement : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.DoWhileStatement;
        public CstDoWhileStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
    }

    /// <summary>
    /// Nodes = Statement
    /// </summary>
    public class CstElseClause : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ElseClause;
        public CstElseClause(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = ((PrefixOperator)*+LeafExpression+(PostfixOperator)*)
    /// </summary>
    public class CstExpression : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Expression;
        public CstExpression(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstPrefixOperator> PrefixOperator => new CstNodeFilter<CstPrefixOperator> (Children);
        public CstNodeFilter<CstLeafExpression> LeafExpression => new CstNodeFilter<CstLeafExpression> (Children);
        public CstNodeFilter<CstPostfixOperator> PostfixOperator => new CstNodeFilter<CstPostfixOperator> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstExpressionBody : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ExpressionBody;
        public CstExpressionBody(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstExpressionStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ExpressionStatement;
        public CstExpressionStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+TypeExpr)
    /// </summary>
    public class CstFieldDeclaration : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.FieldDeclaration;
        public CstFieldDeclaration(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstFieldName : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FieldName;
        public CstFieldName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (TopLevelDeclaration)*
    /// </summary>
    public class CstFile : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.File;
        public CstFile(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTopLevelDeclaration> TopLevelDeclaration => new CstNodeFilter<CstTopLevelDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = CompoundStatement
    /// </summary>
    public class CstFinallyClause : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FinallyClause;
        public CstFinallyClause(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstFloatLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.FloatLiteral;
        public CstFloatLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr+Identifier+Expression+Statement)
    /// </summary>
    public class CstForEachStatement : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForEachStatement;
        public CstForEachStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = (VarDecl)?
    /// </summary>
    public class CstForLoopInit : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForLoopInit;
        public CstForLoopInit(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstVarDecl> VarDecl => new CstNodeFilter<CstVarDecl> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)?
    /// </summary>
    public class CstForLoopInvariant : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForLoopInvariant;
        public CstForLoopInvariant(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)*
    /// </summary>
    public class CstForLoopVariant : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForLoopVariant;
        public CstForLoopVariant(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (ForLoopInit+ForLoopInvariant+ForLoopVariant+Statement)
    /// </summary>
    public class CstForStatement : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.ForStatement;
        public CstForStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstForLoopInit> ForLoopInit => new CstNodeFilter<CstForLoopInit> (Children);
        public CstNodeFilter<CstForLoopInvariant> ForLoopInvariant => new CstNodeFilter<CstForLoopInvariant> (Children);
        public CstNodeFilter<CstForLoopVariant> ForLoopVariant => new CstNodeFilter<CstForLoopVariant> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = ((FunctionArgKeyword)*+Expression)
    /// </summary>
    public class CstFunctionArg : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionArg;
        public CstFunctionArg(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstFunctionArgKeyword> FunctionArgKeyword => new CstNodeFilter<CstFunctionArgKeyword> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstFunctionArgKeyword : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionArgKeyword;
        public CstFunctionArgKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (FunctionArg)*
    /// </summary>
    public class CstFunctionArgs : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionArgs;
        public CstFunctionArgs(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstFunctionArg> FunctionArg => new CstNodeFilter<CstFunctionArg> (Children);
    }

    /// <summary>
    /// Nodes = (ExpressionBody|CompoundStatement)
    /// </summary>
    public class CstFunctionBody : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionBody;
        public CstFunctionBody(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpressionBody> ExpressionBody => new CstNodeFilter<CstExpressionBody> (Children);
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
    }

    /// <summary>
    /// Nodes = MethodDeclaration
    /// </summary>
    public class CstFunctionDeclStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionDeclStatement;
        public CstFunctionDeclStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstMethodDeclaration> MethodDeclaration => new CstNodeFilter<CstMethodDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstFunctionName : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionName;
        public CstFunctionName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+TypeAnnotation)
    /// </summary>
    public class CstFunctionParameter : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionParameter;
        public CstFunctionParameter(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeAnnotation> TypeAnnotation => new CstNodeFilter<CstTypeAnnotation> (Children);
    }

    /// <summary>
    /// Nodes = (FunctionParameter)*
    /// </summary>
    public class CstFunctionParameterList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.FunctionParameterList;
        public CstFunctionParameterList(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstFunctionParameter> FunctionParameter => new CstNodeFilter<CstFunctionParameter> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstHexLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.HexLiteral;
        public CstHexLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstIdentifier : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Identifier;
        public CstIdentifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (ParenthesizedExpression+Statement+(ElseClause)?)
    /// </summary>
    public class CstIfStatement : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.IfStatement;
        public CstIfStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
        public CstNodeFilter<CstElseClause> ElseClause => new CstNodeFilter<CstElseClause> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstImplementsList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ImplementsList;
        public CstImplementsList(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstIndexer : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Indexer;
        public CstIndexer(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstInheritsList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.InheritsList;
        public CstInheritsList(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (InitializationValue)?
    /// </summary>
    public class CstInitialization : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Initialization;
        public CstInitialization(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstInitializationValue> InitializationValue => new CstNodeFilter<CstInitializationValue> (Children);
    }

    /// <summary>
    /// Nodes = (ArrayInitializationValue|Expression)
    /// </summary>
    public class CstInitializationValue : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.InitializationValue;
        public CstInitializationValue(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstArrayInitializationValue> ArrayInitializationValue => new CstNodeFilter<CstArrayInitializationValue> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (InitializerClause)*
    /// </summary>
    public class CstInitializer : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Initializer;
        public CstInitializer(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstInitializerClause> InitializerClause => new CstNodeFilter<CstInitializerClause> (Children);
    }

    /// <summary>
    /// Nodes = ((Identifier)?+Expression)
    /// </summary>
    public class CstInitializerClause : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.InitializerClause;
        public CstInitializerClause(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (CompoundOrSimpleTypeExpr+(TypeArgList)?+ArrayRankSpecifiers)
    /// </summary>
    public class CstInnerTypeExpr : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.InnerTypeExpr;
        public CstInnerTypeExpr(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstCompoundOrSimpleTypeExpr> CompoundOrSimpleTypeExpr => new CstNodeFilter<CstCompoundOrSimpleTypeExpr> (Children);
        public CstNodeFilter<CstTypeArgList> TypeArgList => new CstNodeFilter<CstTypeArgList> (Children);
        public CstNodeFilter<CstArrayRankSpecifiers> ArrayRankSpecifiers => new CstNodeFilter<CstArrayRankSpecifiers> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstIntegerLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.IntegerLiteral;
        public CstIntegerLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr+(Identifier)?)
    /// </summary>
    public class CstIsOperation : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.IsOperation;
        public CstIsOperation(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (CompoundStatement|Expression)
    /// </summary>
    public class CstLambdaBody : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaBody;
        public CstLambdaBody(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (LambdaParameters+LambdaBody)
    /// </summary>
    public class CstLambdaExpr : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaExpr;
        public CstLambdaExpr(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstLambdaParameters> LambdaParameters => new CstNodeFilter<CstLambdaParameters> (Children);
        public CstNodeFilter<CstLambdaBody> LambdaBody => new CstNodeFilter<CstLambdaBody> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstLambdaParameter : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaParameter;
        public CstLambdaParameter(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (LambdaParameter|(LambdaParameter)*)
    /// </summary>
    public class CstLambdaParameters : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.LambdaParameters;
        public CstLambdaParameters(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstLambdaParameter> LambdaParameter => new CstNodeFilter<CstLambdaParameter> (Children);
    }

    /// <summary>
    /// Nodes = (LambdaExpr|CastExpression|ParenthesizedExpression|ThrowExpression|Literal|TypeOf|NameOf|Default|NewOperation|StringInterpolation|Identifier)
    /// </summary>
    public class CstLeafExpression : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.LeafExpression;
        public CstLeafExpression(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstLambdaExpr> LambdaExpr => new CstNodeFilter<CstLambdaExpr> (Children);
        public CstNodeFilter<CstCastExpression> CastExpression => new CstNodeFilter<CstCastExpression> (Children);
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
        public CstNodeFilter<CstThrowExpression> ThrowExpression => new CstNodeFilter<CstThrowExpression> (Children);
        public CstNodeFilter<CstLiteral> Literal => new CstNodeFilter<CstLiteral> (Children);
        public CstNodeFilter<CstTypeOf> TypeOf => new CstNodeFilter<CstTypeOf> (Children);
        public CstNodeFilter<CstNameOf> NameOf => new CstNodeFilter<CstNameOf> (Children);
        public CstNodeFilter<CstDefault> Default => new CstNodeFilter<CstDefault> (Children);
        public CstNodeFilter<CstNewOperation> NewOperation => new CstNodeFilter<CstNewOperation> (Children);
        public CstNodeFilter<CstStringInterpolation> StringInterpolation => new CstNodeFilter<CstStringInterpolation> (Children);
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+(MethodDeclaration)*)
    /// </summary>
    public class CstLibrary : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Library;
        public CstLibrary(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstMethodDeclaration> MethodDeclaration => new CstNodeFilter<CstMethodDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral)
    /// </summary>
    public class CstLiteral : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Literal;
        public CstLiteral(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstHexLiteral> HexLiteral => new CstNodeFilter<CstHexLiteral> (Children);
        public CstNodeFilter<CstBinaryLiteral> BinaryLiteral => new CstNodeFilter<CstBinaryLiteral> (Children);
        public CstNodeFilter<CstFloatLiteral> FloatLiteral => new CstNodeFilter<CstFloatLiteral> (Children);
        public CstNodeFilter<CstIntegerLiteral> IntegerLiteral => new CstNodeFilter<CstIntegerLiteral> (Children);
        public CstNodeFilter<CstStringLiteral> StringLiteral => new CstNodeFilter<CstStringLiteral> (Children);
        public CstNodeFilter<CstCharLiteral> CharLiteral => new CstNodeFilter<CstCharLiteral> (Children);
        public CstNodeFilter<CstBooleanLiteral> BooleanLiteral => new CstNodeFilter<CstBooleanLiteral> (Children);
        public CstNodeFilter<CstNullLiteral> NullLiteral => new CstNodeFilter<CstNullLiteral> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstMemberAccess : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.MemberAccess;
        public CstMemberAccess(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (MethodDeclaration|FieldDeclaration)
    /// </summary>
    public class CstMemberDeclaration : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.MemberDeclaration;
        public CstMemberDeclaration(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstMethodDeclaration> MethodDeclaration => new CstNodeFilter<CstMethodDeclaration> (Children);
        public CstNodeFilter<CstFieldDeclaration> FieldDeclaration => new CstNodeFilter<CstFieldDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+FunctionParameterList+TypeAnnotation+FunctionBody)
    /// </summary>
    public class CstMethodDeclaration : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.MethodDeclaration;
        public CstMethodDeclaration(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstFunctionParameterList> FunctionParameterList => new CstNodeFilter<CstFunctionParameterList> (Children);
        public CstNodeFilter<CstTypeAnnotation> TypeAnnotation => new CstNodeFilter<CstTypeAnnotation> (Children);
        public CstNodeFilter<CstFunctionBody> FunctionBody => new CstNodeFilter<CstFunctionBody> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstNameOf : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.NameOf;
        public CstNameOf(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = ((TypeExpr)?+(FunctionArgs)?+(ArraySizeSpecifier)?+(Initializer)?)
    /// </summary>
    public class CstNewOperation : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.NewOperation;
        public CstNewOperation(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstFunctionArgs> FunctionArgs => new CstNodeFilter<CstFunctionArgs> (Children);
        public CstNodeFilter<CstArraySizeSpecifier> ArraySizeSpecifier => new CstNodeFilter<CstArraySizeSpecifier> (Children);
        public CstNodeFilter<CstInitializer> Initializer => new CstNodeFilter<CstInitializer> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstNullLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.NullLiteral;
        public CstNullLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstOperator : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Operator;
        public CstOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstParameterName : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ParameterName;
        public CstParameterName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)*
    /// </summary>
    public class CstParenthesizedExpression : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ParenthesizedExpression;
        public CstParenthesizedExpression(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (MemberAccess|ConditionalMemberAccess|FunctionArgs|Indexer|TernaryOperation|BinaryOperation|IsOperation|AsOperation)
    /// </summary>
    public class CstPostfixOperator : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.PostfixOperator;
        public CstPostfixOperator(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstMemberAccess> MemberAccess => new CstNodeFilter<CstMemberAccess> (Children);
        public CstNodeFilter<CstConditionalMemberAccess> ConditionalMemberAccess => new CstNodeFilter<CstConditionalMemberAccess> (Children);
        public CstNodeFilter<CstFunctionArgs> FunctionArgs => new CstNodeFilter<CstFunctionArgs> (Children);
        public CstNodeFilter<CstIndexer> Indexer => new CstNodeFilter<CstIndexer> (Children);
        public CstNodeFilter<CstTernaryOperation> TernaryOperation => new CstNodeFilter<CstTernaryOperation> (Children);
        public CstNodeFilter<CstBinaryOperation> BinaryOperation => new CstNodeFilter<CstBinaryOperation> (Children);
        public CstNodeFilter<CstIsOperation> IsOperation => new CstNodeFilter<CstIsOperation> (Children);
        public CstNodeFilter<CstAsOperation> AsOperation => new CstNodeFilter<CstAsOperation> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstPrefixOperator : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.PrefixOperator;
        public CstPrefixOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (Identifier)*
    /// </summary>
    public class CstQualifiedIdentifier : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.QualifiedIdentifier;
        public CstQualifiedIdentifier(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Expression)?
    /// </summary>
    public class CstReturnStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ReturnStatement;
        public CstReturnStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (TypeKeyword|StatementKeyword)
    /// </summary>
    public class CstSeparator : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Separator;
        public CstSeparator(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeKeyword> TypeKeyword => new CstNodeFilter<CstTypeKeyword> (Children);
        public CstNodeFilter<CstStatementKeyword> StatementKeyword => new CstNodeFilter<CstStatementKeyword> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstSimpleTypeExpr : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.SimpleTypeExpr;
        public CstSimpleTypeExpr(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (CompoundStatement|IfStatement|WhileStatement|DoWhileStatement|ReturnStatement|BreakStatement|ContinueStatement|ForStatement|ForEachStatement|FunctionDeclStatement|VarDeclStatement|TryStatement|YieldStatement|SwitchStatement|ExpressionStatement)
    /// </summary>
    public class CstStatement : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Statement;
        public CstStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
        public CstNodeFilter<CstIfStatement> IfStatement => new CstNodeFilter<CstIfStatement> (Children);
        public CstNodeFilter<CstWhileStatement> WhileStatement => new CstNodeFilter<CstWhileStatement> (Children);
        public CstNodeFilter<CstDoWhileStatement> DoWhileStatement => new CstNodeFilter<CstDoWhileStatement> (Children);
        public CstNodeFilter<CstReturnStatement> ReturnStatement => new CstNodeFilter<CstReturnStatement> (Children);
        public CstNodeFilter<CstBreakStatement> BreakStatement => new CstNodeFilter<CstBreakStatement> (Children);
        public CstNodeFilter<CstContinueStatement> ContinueStatement => new CstNodeFilter<CstContinueStatement> (Children);
        public CstNodeFilter<CstForStatement> ForStatement => new CstNodeFilter<CstForStatement> (Children);
        public CstNodeFilter<CstForEachStatement> ForEachStatement => new CstNodeFilter<CstForEachStatement> (Children);
        public CstNodeFilter<CstFunctionDeclStatement> FunctionDeclStatement => new CstNodeFilter<CstFunctionDeclStatement> (Children);
        public CstNodeFilter<CstVarDeclStatement> VarDeclStatement => new CstNodeFilter<CstVarDeclStatement> (Children);
        public CstNodeFilter<CstTryStatement> TryStatement => new CstNodeFilter<CstTryStatement> (Children);
        public CstNodeFilter<CstYieldStatement> YieldStatement => new CstNodeFilter<CstYieldStatement> (Children);
        public CstNodeFilter<CstSwitchStatement> SwitchStatement => new CstNodeFilter<CstSwitchStatement> (Children);
        public CstNodeFilter<CstExpressionStatement> ExpressionStatement => new CstNodeFilter<CstExpressionStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstStatementKeyword : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.StatementKeyword;
        public CstStatementKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (StringInterpolationContent)*
    /// </summary>
    public class CstStringInterpolation : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.StringInterpolation;
        public CstStringInterpolation(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstStringInterpolationContent> StringInterpolationContent => new CstNodeFilter<CstStringInterpolationContent> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstStringInterpolationContent : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.StringInterpolationContent;
        public CstStringInterpolationContent(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstStringLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.StringLiteral;
        public CstStringLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (CaseClause)*
    /// </summary>
    public class CstSwitchStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.SwitchStatement;
        public CstSwitchStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstCaseClause> CaseClause => new CstNodeFilter<CstCaseClause> (Children);
    }

    /// <summary>
    /// Nodes = (Expression+Expression)
    /// </summary>
    public class CstTernaryOperation : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TernaryOperation;
        public CstTernaryOperation(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstThrowExpression : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.ThrowExpression;
        public CstThrowExpression(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (Library|Concept|Type)
    /// </summary>
    public class CstTopLevelDeclaration : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.TopLevelDeclaration;
        public CstTopLevelDeclaration(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstLibrary> Library => new CstNodeFilter<CstLibrary> (Children);
        public CstNodeFilter<CstConcept> Concept => new CstNodeFilter<CstConcept> (Children);
        public CstNodeFilter<CstType> Type => new CstNodeFilter<CstType> (Children);
    }

    /// <summary>
    /// Nodes = (CompoundStatement+(CatchClause)?+(FinallyClause)?)
    /// </summary>
    public class CstTryStatement : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.TryStatement;
        public CstTryStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstCompoundStatement> CompoundStatement => new CstNodeFilter<CstCompoundStatement> (Children);
        public CstNodeFilter<CstCatchClause> CatchClause => new CstNodeFilter<CstCatchClause> (Children);
        public CstNodeFilter<CstFinallyClause> FinallyClause => new CstNodeFilter<CstFinallyClause> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+TypeParameterList+ImplementsList+(FieldDeclaration)*)
    /// </summary>
    public class CstType : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Type;
        public CstType(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstTypeParameterList> TypeParameterList => new CstNodeFilter<CstTypeParameterList> (Children);
        public CstNodeFilter<CstImplementsList> ImplementsList => new CstNodeFilter<CstImplementsList> (Children);
        public CstNodeFilter<CstFieldDeclaration> FieldDeclaration => new CstNodeFilter<CstFieldDeclaration> (Children);
    }

    /// <summary>
    /// Nodes = TypeExpr
    /// </summary>
    public class CstTypeAnnotation : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeAnnotation;
        public CstTypeAnnotation(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = (TypeExpr)*
    /// </summary>
    public class CstTypeArgList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeArgList;
        public CstTypeArgList(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = InnerTypeExpr
    /// </summary>
    public class CstTypeExpr : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeExpr;
        public CstTypeExpr(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstInnerTypeExpr> InnerTypeExpr => new CstNodeFilter<CstInnerTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstTypeKeyword : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeKeyword;
        public CstTypeKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeName : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeName;
        public CstTypeName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = TypeExpr
    /// </summary>
    public class CstTypeOf : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeOf;
        public CstTypeOf(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeParameter : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeParameter;
        public CstTypeParameter(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (TypeParameter)*
    /// </summary>
    public class CstTypeParameterList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeParameterList;
        public CstTypeParameterList(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeParameter> TypeParameter => new CstNodeFilter<CstTypeParameter> (Children);
    }

    /// <summary>
    /// Nodes = (TypeParameterToken)+
    /// </summary>
    public class CstTypeParametersToken : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeParametersToken;
        public CstTypeParametersToken(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeParameterToken> TypeParameterToken => new CstNodeFilter<CstTypeParameterToken> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeParameterToken : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeParameterToken;
        public CstTypeParameterToken(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeVar : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.TypeVar;
        public CstTypeVar(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstUnknown : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Unknown;
        public CstUnknown(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (TypeExpr+(VarWithInitialization)+)
    /// </summary>
    public class CstVarDecl : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.VarDecl;
        public CstVarDecl(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeExpr> TypeExpr => new CstNodeFilter<CstTypeExpr> (Children);
        public CstNodeFilter<CstVarWithInitialization> VarWithInitialization => new CstNodeFilter<CstVarWithInitialization> (Children);
    }

    /// <summary>
    /// Nodes = VarDecl
    /// </summary>
    public class CstVarDeclStatement : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.VarDeclStatement;
        public CstVarDeclStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstVarDecl> VarDecl => new CstNodeFilter<CstVarDecl> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+Initialization)
    /// </summary>
    public class CstVarWithInitialization : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.VarWithInitialization;
        public CstVarWithInitialization(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstInitialization> Initialization => new CstNodeFilter<CstInitialization> (Children);
    }

    /// <summary>
    /// Nodes = (ParenthesizedExpression+Statement)
    /// </summary>
    public class CstWhileStatement : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.WhileStatement;
        public CstWhileStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstParenthesizedExpression> ParenthesizedExpression => new CstNodeFilter<CstParenthesizedExpression> (Children);
        public CstNodeFilter<CstStatement> Statement => new CstNodeFilter<CstStatement> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstYieldBreak : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.YieldBreak;
        public CstYieldBreak(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = Expression
    /// </summary>
    public class CstYieldReturn : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.YieldReturn;
        public CstYieldReturn(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstExpression> Expression => new CstNodeFilter<CstExpression> (Children);
    }

    /// <summary>
    /// Nodes = (YieldReturn|YieldBreak)
    /// </summary>
    public class CstYieldStatement : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.YieldStatement;
        public CstYieldStatement(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstYieldReturn> YieldReturn => new CstNodeFilter<CstYieldReturn> (Children);
        public CstNodeFilter<CstYieldBreak> YieldBreak => new CstNodeFilter<CstYieldBreak> (Children);
    }

}
