// DO NOT EDIT: Autogenerated file created on 2024-03-03 10:34:03 PM. 
using System;
using System.Linq;

namespace Ara3D.Parakeet.Cst.PlatoTokenGrammarNameSpace
{
    /// <summary>
    /// Rule = BinaryLiteral ::= (("0b"|("0B"+(BinDigit)++(IntegerSuffix)?))+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstBinaryLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BinaryLiteral;
        public CstBinaryLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = BinaryOperator ::= ((Symbol('>>>=')|Symbol('and')|Symbol('>>=')|Symbol('<<=')|Symbol('&&=')|Symbol('||=')|Symbol('or')|Symbol('<<')|Symbol('&&')|Symbol('||')|Symbol('+=')|Symbol('-=')|Symbol('*=')|Symbol('/=')|Symbol('%=')|Symbol('&=')|Symbol('|=')|Symbol('^=')|Symbol('<=')|Symbol('>=')|Symbol('==')|Symbol('!=')|Symbol('+')|Symbol('-')|Symbol('*')|Symbol('/')|Symbol('%')|Symbol('&')|Symbol('|')|Symbol('^')|Symbol('=')|Symbol('<')|Symbol('>'))+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstBinaryOperator : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BinaryOperator;
        public CstBinaryOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = BooleanLiteral ::= ((Keyword('true')|Keyword('false'))+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstBooleanLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.BooleanLiteral;
        public CstBooleanLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = CharLiteral ::= (('''+CharLiteralChar+''')+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstCharLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.CharLiteral;
        public CstCharLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = Comment ::= (CppStyleComment+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstComment : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Comment;
        public CstComment(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = Delimiter ::= ([\x28\x29\x5B\x5D\x7B\x7D]+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstDelimiter : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Delimiter;
        public CstDelimiter(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = FieldName ::= (Identifier+_UNKNOWN_)
    /// Nodes = Identifier
    /// </summary>
    public class CstFieldName : CstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FieldName;
        public CstFieldName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = FloatLiteral ::= ((Float+(FloatSuffix)?)+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstFloatLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FloatLiteral;
        public CstFloatLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = FunctionName ::= (Identifier+_UNKNOWN_)
    /// Nodes = Identifier
    /// </summary>
    public class CstFunctionName : CstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.FunctionName;
        public CstFunctionName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = HexLiteral ::= ((("0x"|"0X")+(HexDigit)++(IntegerSuffix)?)+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstHexLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.HexLiteral;
        public CstHexLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = Identifier ::= ((IdentifierFirstChar+(IdentifierChar)*)+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstIdentifier : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Identifier;
        public CstIdentifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = IntegerLiteral ::= ((Digits+!([DFMdfm])+(IntegerSuffix)?)+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstIntegerLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.IntegerLiteral;
        public CstIntegerLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = Literal ::= ((HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral)+_UNKNOWN_)
    /// Nodes = (HexLiteral|BinaryLiteral|FloatLiteral|IntegerLiteral|StringLiteral|CharLiteral|BooleanLiteral|NullLiteral)
    /// </summary>
    public class CstLiteral : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Literal;
        public CstLiteral(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstHexLiteral> HexLiteral => new CstNodeFilter<CstHexLiteral> (Children);
        public CstNodeFilter<CstBinaryLiteral> BinaryLiteral => new CstNodeFilter<CstBinaryLiteral> (Children);
        public CstNodeFilter<CstFloatLiteral> FloatLiteral => new CstNodeFilter<CstFloatLiteral> (Children);
        public CstNodeFilter<CstIntegerLiteral> IntegerLiteral => new CstNodeFilter<CstIntegerLiteral> (Children);
        public CstNodeFilter<CstStringLiteral> StringLiteral => new CstNodeFilter<CstStringLiteral> (Children);
        public CstNodeFilter<CstCharLiteral> CharLiteral => new CstNodeFilter<CstCharLiteral> (Children);
        public CstNodeFilter<CstBooleanLiteral> BooleanLiteral => new CstNodeFilter<CstBooleanLiteral> (Children);
        public CstNodeFilter<CstNullLiteral> NullLiteral => new CstNodeFilter<CstNullLiteral> (Children);
    }

    /// <summary>
    /// Rule = NullLiteral ::= (Keyword('null')+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstNullLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.NullLiteral;
        public CstNullLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = Operator ::= (([\x21\x23-\x26\x2A+\x2D\x2F\x3A<-\x40^|~])++_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstOperator : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Operator;
        public CstOperator(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = ParameterName ::= (Identifier+_UNKNOWN_)
    /// Nodes = Identifier
    /// </summary>
    public class CstParameterName : CstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.ParameterName;
        public CstParameterName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = Separator ::= (([\x2C\x2E\x3B]|TypeKeyword|StatementKeyword)+_UNKNOWN_)
    /// Nodes = (TypeKeyword|StatementKeyword)
    /// </summary>
    public class CstSeparator : CstNodeChoice
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Separator;
        public CstSeparator(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstTypeKeyword> TypeKeyword => new CstNodeFilter<CstTypeKeyword> (Children);
        public CstNodeFilter<CstStatementKeyword> StatementKeyword => new CstNodeFilter<CstStatementKeyword> (Children);
    }

    /// <summary>
    /// Rule = StatementKeyword ::= ((Keyword('continue')|Keyword('foreach')|Keyword('finally')|Keyword('default')|Keyword('return')|Keyword('switch')|Keyword('break')|Keyword('throw')|Keyword('catch')|Keyword('using')|Keyword('case')|Keyword('for')|Keyword('try')|Keyword('if')|Keyword('do'))+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstStatementKeyword : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StatementKeyword;
        public CstStatementKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = StringLiteral ::= ((('@')?+'"'+(StringLiteralChar)*+'"')+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstStringLiteral : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.StringLiteral;
        public CstStringLiteral(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = TypeKeyword ::= ((Keyword('concept')|Keyword('library')|Keyword('type'))+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstTypeKeyword : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeKeyword;
        public CstTypeKeyword(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Rule = TypeName ::= (Identifier+_UNKNOWN_)
    /// Nodes = Identifier
    /// </summary>
    public class CstTypeName : CstNode
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeName;
        public CstTypeName(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Rule = TypeParametersToken ::= (('<'+CommentOrSpaces+TypeParameterToken+CommentOrSpaces+((','+CommentOrSpaces+TypeParameterToken))*+'>'+CommentOrSpaces)+_UNKNOWN_)
    /// Nodes = ((Comment)*+TypeParameterToken+(Comment)*+(((Comment)*+TypeParameterToken))*+(Comment)*)
    /// </summary>
    public class CstTypeParametersToken : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeParametersToken;
        public CstTypeParametersToken(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstComment> Comment => new CstNodeFilter<CstComment> (Children);
        public CstNodeFilter<CstTypeParameterToken> TypeParameterToken => new CstNodeFilter<CstTypeParameterToken> (Children);
    }

    /// <summary>
    /// Rule = TypeParameterToken ::= ((Identifier+CommentOrSpaces+TypeAnnotationToken)+_UNKNOWN_)
    /// Nodes = (Identifier+(Comment)*)
    /// </summary>
    public class CstTypeParameterToken : CstNodeSequence
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.TypeParameterToken;
        public CstTypeParameterToken(params CstNode[] children) : base(children) { }
        public CstNodeFilter<CstIdentifier> Identifier => new CstNodeFilter<CstIdentifier> (Children);
        public CstNodeFilter<CstComment> Comment => new CstNodeFilter<CstComment> (Children);
    }

    /// <summary>
    /// Rule = Unknown ::= (AnyChar+_UNKNOWN_)
    /// Nodes = 
    /// </summary>
    public class CstUnknown : CstNodeLeaf
    {
        public static Rule Rule = CstNodeFactory.StaticGrammar.Unknown;
        public CstUnknown(string text) : base(text) { }
        // No children
    }

}
