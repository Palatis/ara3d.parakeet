// DO NOT EDIT: Autogenerated file created on 2024-01-26 1:43:40 AM. 
using System;
using System.Linq;
using Ara3D.Parsing;

namespace Parakeet.Cst.XmlGrammar
{
    /// <summary>
    /// Nodes = (Name+AttrValue)
    /// </summary>
    public class CstAttr : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Attr;
        public CstAttr(params CstNode[] children) : base(children) { }
        public CstFilter<CstName> Name => new CstFilter<CstName> (Children);
        public CstFilter<CstAttrValue> AttrValue => new CstFilter<CstAttrValue> (Children);
    }

    /// <summary>
    /// Nodes = (Attr)*
    /// </summary>
    public class CstAttrList : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.AttrList;
        public CstAttrList(params CstNode[] children) : base(children) { }
        public CstFilter<CstAttr> Attr => new CstFilter<CstAttr> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstAttrValue : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.AttrValue;
        public CstAttrValue(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstCData : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.CData;
        public CstCData(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = CData
    /// </summary>
    public class CstCDSect : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.CDSect;
        public CstCDSect(params CstNode[] children) : base(children) { }
        public CstFilter<CstCData> CData => new CstFilter<CstCData> (Children);
    }

    /// <summary>
    /// Nodes = Element
    /// </summary>
    public class CstContent : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Content;
        public CstContent(params CstNode[] children) : base(children) { }
        public CstFilter<CstElement> Element => new CstFilter<CstElement> (Children);
    }

    /// <summary>
    /// Nodes = ((Prolog)?+Element)
    /// </summary>
    public class CstDocument : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Document;
        public CstDocument(params CstNode[] children) : base(children) { }
        public CstFilter<CstProlog> Prolog => new CstFilter<CstProlog> (Children);
        public CstFilter<CstElement> Element => new CstFilter<CstElement> (Children);
    }

    /// <summary>
    /// Nodes = (DTDInternalSubset)?
    /// </summary>
    public class CstDTD : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.DTD;
        public CstDTD(params CstNode[] children) : base(children) { }
        public CstFilter<CstDTDInternalSubset> DTDInternalSubset => new CstFilter<CstDTDInternalSubset> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstDTDInternalSubset : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.DTDInternalSubset;
        public CstDTDInternalSubset(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (EmptyElementTag|(StartTag+Content+EndTag))
    /// </summary>
    public class CstElement : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Element;
        public CstElement(params CstNode[] children) : base(children) { }
        public CstFilter<CstEmptyElementTag> EmptyElementTag => new CstFilter<CstEmptyElementTag> (Children);
        public CstFilter<CstStartTag> StartTag => new CstFilter<CstStartTag> (Children);
        public CstFilter<CstContent> Content => new CstFilter<CstContent> (Children);
        public CstFilter<CstEndTag> EndTag => new CstFilter<CstEndTag> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+AttrList)
    /// </summary>
    public class CstEmptyElementTag : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.EmptyElementTag;
        public CstEmptyElementTag(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstAttrList> AttrList => new CstFilter<CstAttrList> (Children);
    }

    /// <summary>
    /// Nodes = Identifier
    /// </summary>
    public class CstEndTag : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.EndTag;
        public CstEndTag(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier|HexEntityValue|NumericEntityValue)
    /// </summary>
    public class CstEntity : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Entity;
        public CstEntity(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstHexEntityValue> HexEntityValue => new CstFilter<CstHexEntityValue> (Children);
        public CstFilter<CstNumericEntityValue> NumericEntityValue => new CstFilter<CstNumericEntityValue> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstHexEntityValue : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.HexEntityValue;
        public CstHexEntityValue(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstIdentifier : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Identifier;
        public CstIdentifier(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = PI
    /// </summary>
    public class CstMisc : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.Misc;
        public CstMisc(params CstNode[] children) : base(children) { }
        public CstFilter<CstPI> PI => new CstFilter<CstPI> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstName : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Name;
        public CstName(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = (StartTag+Content+EndTag)
    /// </summary>
    public class CstNonEmptyElement : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.NonEmptyElement;
        public CstNonEmptyElement(params CstNode[] children) : base(children) { }
        public CstFilter<CstStartTag> StartTag => new CstFilter<CstStartTag> (Children);
        public CstFilter<CstContent> Content => new CstFilter<CstContent> (Children);
        public CstFilter<CstEndTag> EndTag => new CstFilter<CstEndTag> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+(Identifier)?)
    /// </summary>
    public class CstNSIdent : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.NSIdent;
        public CstNSIdent(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstNumericEntityValue : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.NumericEntityValue;
        public CstNumericEntityValue(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstPI : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.PI;
        public CstPI(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = ((XmlDecl)?+(Misc)*+(DTD)?+(Misc)*)
    /// </summary>
    public class CstProlog : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Prolog;
        public CstProlog(params CstNode[] children) : base(children) { }
        public CstFilter<CstXmlDecl> XmlDecl => new CstFilter<CstXmlDecl> (Children);
        public CstFilter<CstMisc> Misc => new CstFilter<CstMisc> (Children);
        public CstFilter<CstDTD> DTD => new CstFilter<CstDTD> (Children);
    }

    /// <summary>
    /// Nodes = ((Prolog)?+Element)
    /// </summary>
    public class CstDocument : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.Document;
        public CstDocument(params CstNode[] children) : base(children) { }
        public CstFilter<CstProlog> Prolog => new CstFilter<CstProlog> (Children);
        public CstFilter<CstElement> Element => new CstFilter<CstElement> (Children);
    }

    /// <summary>
    /// Nodes = (Identifier+AttrList)
    /// </summary>
    public class CstStartTag : CstSequence
    {
        public static Rule Rule = CstNodeFactory.Grammar.StartTag;
        public CstStartTag(params CstNode[] children) : base(children) { }
        public CstFilter<CstIdentifier> Identifier => new CstFilter<CstIdentifier> (Children);
        public CstFilter<CstAttrList> AttrList => new CstFilter<CstAttrList> (Children);
    }

    /// <summary>
    /// Nodes = (EndTag|EmptyElementTag|StartTag)
    /// </summary>
    public class CstTag : CstChoice
    {
        public static Rule Rule = CstNodeFactory.Grammar.Tag;
        public CstTag(params CstNode[] children) : base(children) { }
        public CstFilter<CstEndTag> EndTag => new CstFilter<CstEndTag> (Children);
        public CstFilter<CstEmptyElementTag> EmptyElementTag => new CstFilter<CstEmptyElementTag> (Children);
        public CstFilter<CstStartTag> StartTag => new CstFilter<CstStartTag> (Children);
    }

    /// <summary>
    /// Nodes = 
    /// </summary>
    public class CstText : CstLeaf
    {
        public static Rule Rule = CstNodeFactory.Grammar.Text;
        public CstText(string text) : base(text) { }
        // No children
    }

    /// <summary>
    /// Nodes = AttrList
    /// </summary>
    public class CstXmlDecl : CstNode
    {
        public static Rule Rule = CstNodeFactory.Grammar.XmlDecl;
        public CstXmlDecl(params CstNode[] children) : base(children) { }
        public CstFilter<CstAttrList> AttrList => new CstFilter<CstAttrList> (Children);
    }

}
